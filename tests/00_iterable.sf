include sidefext::object
include sidefext::iterable

100.times {
  assert_eq(
    Hash(
      :change_me => true,
      :dont_change_me => false,
      :here => 1
    ).clobber_existing_by(
      Hash( :change_me => { :new_val }, :dont_change_me => { :okay_i_wont }, :here => { :there } )
    ),

    Hash( :change_me => :new_val, :dont_change_me => false, :here => :there )
  )

  assert_eq(
    Hash(
      :bool => "a string",
      :abc => "ab",
      :something => nil
    ).template_transform( :( :bool => Bool, :abc => Array, :something => Bool ) ),
    Hash(
      :bool => true,
      :abc => [:ab],
      :something => false
    )
  )

  assert_eq(
    Hash(
      :bool => :1,
      :abc => Set(9, 0, 1),
      :something => :dont_cast
      :simple_entry => :2,
      :boolify => nil
    ).template_transform( :(
      # still want ability to check against subsets directly
      # but don't necessarily want a subset for each of these entries
      :bool => :( :type => [String, Number], :default => false ),
      :abc => :( :type => Array, :maybe_cast => { .to_array }, :conv => { .sort } ),
      :something => :( :type => String, :maybe_cast => { die "don't call this" }, :conv => { .reverse } )
      :simple_entry => Number,
      :boolify => Bool
    ) ),
    Hash(
      :bool => :1,
      :abc => [0, 1, 9],
      :something => :tsac_tnod,
      :simple_entry => 2,
      :boolify => false
    )
  )

  assert_eq(
    Hash( :old_key => :1 ).template_transform( Hash( :old_key => Number, :new_key => Array ) ),
    Hash( :old_key => 1, :new_key => [] )
  )

  assert_eq(
    Hash( 1 => { assert_eq(_, :1); 2 }, 3 => { 4 }, 5 => { assert_eq(_, :5); 6 } ).run_keys(:1, :5),
    :( 1 => 2, 5 => 6)
  )

  assert_eq(
    Hash( 1 => { assert_eq(_, :1); 2 }, 3 => { 4 }, 5 => { assert_eq(_, :5); 6 } ).ordered_run_keys(:1, :5),
    [2, 6]
  )

  assert_eq(
    Hash( :c => :b, :a => :d ).change_extant_keys( :( :a => { _.uc }, :c => { _.lc }, :x => { die "don't call this" } ) ),
    Hash( :c => :b, :a => :D )
  )

  assert_eq(
    hashset::hash_intersect_set(Hash( 1 => 2, 3 => 4, 5 => 6 ), Set(:3, :5))
    Hash( 3 => 4, 5 => 6 )
  )

  assert_eq(
    hashset::hash_intersect_hash(Hash( 1 => 2, 3 => 4, 5 => 6 ), Hash(3 => 5))
    Hash( 3 => 4 )
  )

  assert_eq(
    hashset::hash_intersect_hash(Hash(3 => 5), Hash( 1 => 2, 3 => 4, 5 => 6 )),
    Hash( 3 => 5 )
  )

  assert_eq(
    hashset::hash_diff_set(Hash( 1 => 2, 3 => 4, 5 => 6 ), Set())
    Hash( 1 => 2, 3 => 4, 5 => 6 )
  )
}
