#! ruby
include sidefext::xchg
include Explicit
import Explicit::EXPL_VAL
import Explicit::EXPL_TYP
import Explicit::EXPL_STP
import Explicit::make
import Explicit::tag
import Explicit::_major_subtype_heuristic
_major_subtype_heuristic

assert_eq( Num.ref _major_subtype_heuristic([0 1 2 3]) )
assert_eq( false _major_subtype_heuristic([:1 2 3 4]) )
assert_eq( Num.ref _major_subtype_heuristic(:(0 1 2 3)) )
assert_eq( Str.ref _major_subtype_heuristic(:(0, :1 2, :3)) )

assert_eq( make( nil, 0 ), :( EXPL_VAL 0 ) )
assert_eq( make( '', 0 ), :( EXPL_VAL 0 ) )
assert_eq( make( Str.ref, :0 ), :( EXPL_TYP Str.ref EXPL_VAL, :0 ) )
assert_eq( make( Num.ref, 0 ), :( EXPL_TYP Num.ref EXPL_VAL 0 ) )
assert_eq( make( Arr.ref, [] ), :( EXPL_TYP Arr.ref EXPL_VAL [] ) )

assert_eq(
  make( Str.ref, 0, Num.ref ),
  :( EXPL_TYP Str.ref EXPL_VAL 0 EXPL_STP Num.ref )
)
assert_eq(
  make( Str.ref, 0, Num.ref ),
  :( EXPL_TYP Str.ref EXPL_VAL 0 EXPL_STP Num.ref )
)
assert_eq(
  make( Arr.ref, [0 1]*7, Num.ref ),
  :( EXPL_TYP Arr.ref EXPL_VAL [0 1]*7 EXPL_STP Num.ref )
)
assert_eq(
  make( Arr.ref, [0 1]*7, nil ),
  :( EXPL_TYP Arr.ref EXPL_VAL [0 1]*7 )
)
assert_eq(
  make( false, [0 1]*7, nil ),
  :( EXPL_VAL [0 1]*7 )
)

assert_eq( tag(2),  :( EXPL_TYP   Num.ref EXPL_VAL 2 ) )
assert_eq( tag(2),  make( Num.ref  2 ) )
assert_eq( tag(:2), :( EXPL_TYP Str.ref  EXPL_VAL, :2 ) )
assert_eq( tag(:2), make( Str.ref, :2 ) )
assert_eq( tag(:2), make( Str.ref, :2 ) )

assert_eq( tag([]), :( EXPL_TYP Arr.ref EXPL_VAL [] ) )
assert_eq( tag([0 1]), :(
    EXPL_TYP Arr.ref
    EXPL_VAL [ :(EXPL_VAL 0), :(EXPL_VAL 1) ]
    EXPL_STP Num.ref
  )
)

assert_eq( tag([0, :1]), :(
    EXPL_TYP Arr.ref
    EXPL_VAL [ :(EXPL_TYP Num.ref EXPL_VAL 0), :(EXPL_TYP Str.ref EXPL_VAL, :1) ]
  )
)

assert_eq( tag([[0 0], [1 1]]), :(
    EXPL_TYP Arr.ref
    EXPL_STP Arr.ref
    EXPL_VAL [
      :( EXPL_STP Num.ref EXPL_VAL [:(EXPL_VAL 0), :(EXPL_VAL 0)])
      :( EXPL_STP Num.ref EXPL_VAL [:(EXPL_VAL 1), :(EXPL_VAL 1)])
    ]
  )
)
