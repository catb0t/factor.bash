include lib::ABCs
import lib::ABCs::Serializable

include lib::frext

class X {
  -> no_arg { }
  -> arg_1 (x) { x }

  -> _hidden_method {}

  has property
}
var i = X()

assert( i.declares_method(:property) )
assert( i.declares_method(:no_arg) )
assert( i.declares_method(:arg_1) )
assert( Object.new.declares_method(:new) )
assert( ! i.declares_method(:_hidden_method) )

assert( i.respond_to(:property) )
assert( i.respond_to(:no_arg) )
assert( i.respond_to(:arg_1) )
assert( i.respond_to(:_hidden_method) )
assert( ! Object.respond_to(:compile_to_perl) )
assert( ! i.respond_to(:non_existent__) )

assert( i.has_overload( :( :callers => [:test], :name => :no_arg) ){:state} )
assert( i.has_overload( :( :callers => [:test], :name => :_hidden_method) ){:state} )
assert( i.has_overload( :( :callers => [:test], :name => :property) ){:state} )
assert( i.has_overload( :( :callers => [:test], :name => :property, :args => [1] ) ){:state} )
assert( i.has_overload( :( :callers => [:test], :name => :property, :args => [1, 2]) ){:state} )
assert( i.has_overload( :( :callers => [:test], :name => :property, :args => [1, 2, 3]) ){:state} )
assert( i.has_overload( :( :callers => [:test], :name => :arg_1,    :args => [1] ) ){:state} )

assert( ! i.has_overload( :( :callers => [:test1], :name => :no_arg, :args => [1]) ){:state} )
assert( ! i.has_overload( :( :callers => [:test1], :name => :no_arg, :args => [1, 2]) ){:state} )
assert( ! i.has_overload( :( :callers => [:test1], :name => :_hidden_method, :args => [1]) ){:state} )
assert( ! i.has_overload( :( :callers => [:test1], :name => :_hidden_method, :args => [1]) ){:state} )
assert( ! i.has_overload( :( :callers => [:test1], :name => :arg_1) ){:state} )
assert( ! i.has_overload( :( :callers => [:test1], :name => :arg_1, :args => [1, 2]) ){:state} )

assert( i.has_public_concrete_method(:test2, :no_arg) )
assert( i.has_public_concrete_method(:test2, :arg_1) )
assert( i.has_public_concrete_method(:test2, :property) )
assert( ! i.has_public_concrete_method(:test2, :_hidden_method) )
assert( ! Object.has_public_concrete_method(:test2, :compile_to_perl) )

assert( i.has_public_concrete_overload(:test3, :no_arg) )
assert( i.has_public_concrete_overload(:test3, :arg_1, 1) )
assert( i.has_public_concrete_overload(:test3, :property, 1) )
assert( i.has_public_concrete_overload(:test3, :property, 1, 2) )
assert( ! i.has_public_concrete_overload(:test3, :no_arg, 1) )
assert( ! i.has_public_concrete_overload(:test3, :arg_1, 1, 2) )
assert( ! i.has_public_concrete_overload(:test3, :_hidden_method) )
assert( ! i.has_public_concrete_overload(:test3, :_hidden_method, 1) )
assert( ! i.has_public_concrete_overload(:test3, :_hidden_method, 1, 2) )

assert( i.is_property(:test4, :property, :arg) )
assert( ! i.is_property(:test4, :_property, :arg) )
assert( ! i.is_property(:test4, :NOTHING, :arg) )
assert( ! i.is_property(:test4, :no_arg, :arg) )
assert( ! i.is_property(:test4, :arg_1, :arg) )
assert( ! i.is_property(:test4, :_hidden_method, :arg) )

assert( TypeUtils::is_typename(Object) )
assert( TypeUtils::is_typename(String) )
assert( TypeUtils::is_typename(X) )
assert( ! TypeUtils::is_typename(i) )
assert( ! TypeUtils::is_typename(1) )
assert( ! TypeUtils::is_typename("") )
assert( ! TypeUtils::is_typename(String()) )

assert( TypeUtils::is_fqco(i) )
assert( TypeUtils::is_fqco(i, :property) )
assert( TypeUtils::is_fqco("i", :len) )
assert( TypeUtils::is_fqco(String(), :len) )
assert( TypeUtils::is_fqco(Object.new, :methods) )
assert( ! TypeUtils::is_fqco(X, :property) )
assert( ! TypeUtils::is_fqco(String, :property) )
assert( ! TypeUtils::is_fqco(Object, :property) )

assert( ! TypeUtils::is_serializable( Object.new ) )
assert( ! TypeUtils::is_serializable( String() ) )
assert( ! TypeUtils::is_serializable( Hash() ) )

assert( ! Serializable()._is_serialized_obj(Hash) )
assert( ! Serializable()._is_serialized_obj(Hash()) )
assert( ! Serializable()._is_serialized_obj(Hash(1)) )
assert( ! Serializable()._is_serialized_obj(Hash(:_serial_type => "")) )
assert( ! Serializable()._is_serialized_obj(Hash(:_serial_type => String)) )
assert( ! Serializable()._is_serialized_obj(Hash(:_serial_value => "value")) )
assert( ! Serializable()._is_serialized_obj(Hash(:_serial_value => Hash)) )
assert( ! Serializable()._is_serialized_obj(Hash(:_serial_type => "", :_serial_value => "value")) )
assert( ! Serializable()._is_serialized_obj(Hash(:_serial_type => String, :_serial_value => "value")) )
assert( ! Serializable()._is_serialized_obj(Hash(:_serial_type => "", :_serial_value => Hash)) )
assert( ! Serializable()._is_serialized_obj(Hash(:_serial_type => String, :_serial_value => Hash())) )
assert( ! Serializable()._is_serialized_obj(Hash(:_serial_type => "String", :_serial_value => Hash())) )
assert( Serializable()._is_serialized_obj( Hash( :_serial_value => Hash() ) ) )
