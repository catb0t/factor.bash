#! ruby
class Object {
  method cleave (*blocks) {
    blocks.map{ .run(self) } # ...
  }
  method ifold (*bv_pairs) {
    bv_pairs.map{ |p| p.first.run( self, @(p.second)... ) }
  }
  # ???
  -> _map_cleave_r (blocks, vals) {
    if (blocks) {
      # clone?
      var newval = blocks[0].run(self)
      self = newval
      self._map_cleave_r( [ blocks[1..blocks.len] ], [vals..., newval] )
    }
  }
  # by-block accumulate
  method map_cleave (*blocks) {
    var vals = []
    foreach blocks {
        |block|
      vals.append( block.run(self) )
      self = vals.last
    }
    vals
  }
  -> has_method (String name, Bool give_msg = false, *args) {
    try {
      # don't change self
      self.dclone.method(name)(args...)
      true
    } catch {
        |_, msg|
      give_msg && msg
    }
  }

  # there's no direct way to tell if an object method is a property declared with "has"
  #   or an accessor declared with -> name ...
  # but if we call it with too many / wrong type arguments and it fails, it's a setter accessor
  #   if it's called with too many / wrong type arguments and doesn't care, it's a property
  # this does require accessors to have a clearly defined argument list, hopefully with types
  #   or else it will overwrite the accessor with a simple property...
  #   which is what you get for using simple blocks with |_| captures,
  #   or no typed parameters in setter accessors :)
  -> is_property (String name, Object arg) {
    # if has_method fails for a reason related to invocation,
    #   it's a setter accessor with a parameter list and not a property
    /does not match/ !~ self.has_method(name, give_msg: true, arg, :extra_arg)
  }
  -> serializable {
    self.has_method(:serial_properties)
  }
}

class Array {
  method all_eq {
    self«==»
  }
  method all {
    self.all{ _ }
  }
  method none {
    self.all{ !_ }
  }
  method all_neq {
    self.combinations(2).map{ !.all_eq }.all
  }
}

# i really must apologise for writing all these abstract classes, it's unlike me
# something has come over me... it's simply too easy.....

# can be turned into a pure-perl representation
/* abstract interface */ # /
class Serializable {
  # has Hash serial_properties

  -> _serial_properties_excluding (Array x) {
    self.methods \
      .grep_kv{ |k, _| k ~~ /^serial_properties/ } \
      .values \
      .map{ |mth| mth().grep_kv{ |k, _| !x.contains(k) } } \
      .reduce{ |l, r| l.merge(r) }
  }
  # -> _do_serial (Array x) -> Block {
  #   func (Block d) { self.serial_properties_excluding(x).map_kv(d) }
  # }
  -> _do_serial (Array x, Block d) -> Hash {
    self._serial_properties_excluding(x).map_kv(d)
  }
  # every object we encount is either Serializable or builtin
  # if it's incorrectly written as non-builtin and non-Serializable
  # then it will appear as a round-trip error
  method serialize (Array exclude = []) -> Hash {
    self._do_serial(exclude, {
        |prop, typename|
      # call the accessor if it's an accessor, otherwise call the property-method
      const value = self.method( prop )()

      # say "serialize '#{prop}' serializable: #{s10e} type: #{typename} value: #{value.dump}"
      ( (prop) => (
        value.serializable
          ? Hash(:_serial_type => typename, :_serial_value => value.serialize)
          : value
        )
      )
    })
  }

  method unserialize (Hash data, Array exclude = [], Bool only_extant_fields = false) -> __CLASS__ {
    self._do_serial(exclude, {
        |prop, typename|
      # when only_extant_fields is true, don't fill all missing keys in data as nil
      if (only_extant_fields && !data.has_key(prop) ) {
        return nil
      }
      const entry = data{prop}
      # say "unserialize call method '#{prop}'"

      # making a new SerialHash container class would defeat the purpose of Serializable
      # we need to distinguish "internal" hashes from actual ones
      # missing feature: can't smartmatch against subsets

      if (
        entry.is_a( Hash ) && entry.keys.sort==[:_serial_type, :_serial_value] && entry{:_serial_value}.is_a( Hash )
      ) {
        die "unserialize typecheck: #{entry{:_serial_type}} !~ #{typename}}" \
          if (entry{:_serial_type} !~ typename)

        entry{:_serial_type}() \
          .unserialize( entry{:_serial_value}, exclude: exclude, only_extant_fields: only_extant_fields )
        #const new_obj = entry{:_serial_type}()
        ### is this ever false?
        #(new_obj.serializable
        #  ? new_obj.unserialize( entry{:_serial_value}, exclude: exclude, only_extant_fields: only_extant_fields )
        #  : new_obj)
      } else {
        entry
      }.cleave{
          |derived|
        # need to test whether prop is an accessor or plain property-method
        if ( self.is_property(prop, derived) ){
          # say "#{prop} is a property"
          self{prop} = derived
        } else {
          # say "#{prop} is an accessor"
          self.method( prop )( derived )
        }
      }
    })

    self
  }
}

# use the serializable functionality to equate two objects
/* abstract interface */
class SeriallyEquatable < Serializable {
  -> _serial_eq (other, exclude_props = []) -> Bool {

    if (other ~~ Serializable) {
      other.serialize(exclude: exclude_props) == self.serialize(exclude: exclude_props)

    # somehow... maybe other is our superclass
    } elsif (other ~~ self) {
     [self, other].map{
       |obj| self._do_serial(exclude_props, { obj.method(_)() } )
     }«==»

    } else { self._do_serial(exclude_props, { other{_} == self{_} } ).all }
  }
  method == (other) { self._serial_eq(other) }
}

# finally some concrete code
class DirSum (Str algo = '', Str names = '', Str contents = '') < SeriallyEquatable {
  has Hash serial_properties = [:algo, :names, :contents].map{ ( (_) => Str ) }.to_h
}

class SrcSums (DirSum vm = DirSum(), DirSum core = DirSum(), DirSum basis = DirSum(), Bool basis_ignored = false ) < SeriallyEquatable {
  has Hash serial_properties = Hash(
    :basis_ignored => Bool,
    [:vm, :core, :basis].map{ ( (_) => DirSum ) }...
  )
}

class BlobSums (Str algo = '', Str vm = '', Str lib = '', Str boot = '') < SeriallyEquatable {
  has Hash serial_properties = [:algo, :vm, :lib, :boot].map{ ( (_) => Str ) }.to_h
  method =~ (other) { self._serial_eq(other, exclude_props: [:boot]) }
}

class VirtualBase64Blob (Str data = '', Str algo = '', Str sum ='') < SeriallyEquatable {
  has Hash serial_properties = [:data, :algo, :sum].map{ ( (_) => Str ) }.to_h
}

/* mixin */ # /
class InitExtender {
  method init {
    self.methods.grep_kv{ _ ~~ /^_extend_init_with/ }.each_kv{ |_, v| v().each{ .run(self) } }
  }
}

# generates accessors based on the serializable properties
# TODO: add support for the serial_properties values being arrays with defaults
#   and custom accessors
/* abstract interface */ # /
class SeriallyAccessible << InitExtender, SeriallyEquatable {
  has Bool _impl_locked = false
  has String _impl_write_locked = 'attempt of write to locked '+__CLASS_NAME__+' object!'

  -> lock { self._impl_locked = true }
  -> lock (Bool b) { self._impl_locked = b }
  -> unlock { self._impl_locked = false }

  has Array _extend_init_with_seriallyaccessible = [ { |self| self._generate_serial_accessors } ]

  method _generate_serial_accessors {
    self._do_serial([], {
        |k, v|
      const typename = (v[0] || v)
      const default_val = (v[1] || v())
      const custom_blocks = (v[2] || Hash())

      (typename ~~ default_val) \
        || die (
          "SeriallyAccessible > #{__CLASS_NAME__}: init: type mismatch in default value for '#{k}': ",
          "want '#{typename}'; got '#{default_val.class}' ('#{default_val.dump}')"
      )

      # create the slot
      self{:_ + k} = default_val

      const Block setter_prelude = {
        .is_a(typename) \
          || die(
            "SeriallyAccessible > #{__CLASS_NAME__}: #{__METHOD_NAME__}: ",
            "type mismatch in setter '#{k}': want '#{typename}'; got '#{_.class}'  ('#{default_val.dump}')"
        )

        die (self._impl_write_locked, ": in ", __METHOD_NAME__) if (self._impl_locked)
      }

      # conditionally define a function in the current scope...
      ( defined( custom_blocks{:get} )
        ? -> accessor (self) { custom_blocks{:get}.run(self) }
        : -> accessor (self) { self{:_ + k} }
      )

      # ...with an overload
      ( defined( custom_blocks{:set} )
        ? -> accessor (self, new_val) { setter_prelude.run(new_val); custom_blocks{:set}.run(self, new_val) }
        : -> accessor (self, new_val) { setter_prelude.run(new_val); self{:_ + k} = new_val }
      )

      # template<typename T>
      __CLASS__.def_method(k, accessor)
    })
  }
}

# class TimeSpec < Serializable {}

class BuiltObj < SeriallyAccessible {
  has Hash serial_properties = Hash(
    :id => Str,
    :factor_version => Str,
    :is_git => Bool,
    :git_branch => Str,
    :git_hash => Str,

    :os_type => Str,
    :os_name => Str,
    :arch_name => Str,
    :word_size => Str,

    :stored_boot_image => VirtualBase64Blob,
    :src_sums => SrcSums,
    :blob_sums => BlobSums,
    :blob_algorithm => [Str, :sha256, :( :get => { |self| self.blob_sums.algo || self._blob_algorithm } ) ], # default: sha256

    :time_created => Num,
    :time_modified => Num,
    :time_accessed => Num,
    :time_tombstoned => [Str, :never], # default: never

    # this is probably useless
    # all same length and support platform-prefixes
    :vm_format    => Array,
    :image_format => Array,
    :lib_format   => Array,
    :boot_format  => Array
  )

  # create boot_fullname etc
  has Array _extend_init_with_builtobj = [ {
      |self|
    [:vm, :lib, :image, :boot].each{
        |name|
      const name_format = name+:_format
      __CLASS__.def_method(name + :_fullname, -> () -> File {
        File( String( self.method(name_format)[0, 1] ) + self.id + self.method(name_format)[2] )
      })
    }
  } ]

  # next step: code generation for these methods too, by a special _extra_init_blocks
  #   property that get invoked at the end of init() to generate these methods
  # want a version of insert that doesn't change its object unless ! is used
  # -> vm_fullname ()    -> File { File( "#{self.vm_format[0, 1]}#{self.id}#{self.vm_format[2]}" ) }
  # -> image_fullname () -> File { File( "#{self.image_format[0, 1]}#{self.id}#{self.image_format[2]}" ) }
  # -> lib_fullname ()   -> File { File( "#{self.lib_format[0, 1]}#{self.id}#{self.lib_format[2]}" ) }
  # -> boot_fullname ()  -> File { File( "#{self.boot_format[0, 1]}#{self.id}#{self.boot_format[2]}" ) }
}


/* abstract */ # /
class WithDirectory {
  -> with_directory (operation) {
    var oldwd = Dir.cwd
    if (oldwd == self.wd) {
      operation.run
    } else {
      self.wd.chdir
      var r = operation.run
      oldwd.chdir
      r
    }
  }
}

/* abstract */ class CapturedWriter < WithDirectory {
  method capture_write_disk (String caller_name, Block operation) {
    if (! self.dry_run) {
      self.log.vbs(__FILE__, __LINE__, __METHOD_NAME__, "#{caller_name}: writing disk with", operation)
      return self.with_directory( operation )
    }
    self.log.vbs(__FILE__, __LINE__, __METHOD_NAME__, "#{caller_name}: not writing disk (dry run)")
    nil
  }
}
