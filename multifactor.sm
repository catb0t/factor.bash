#! ruby
#! sidef -vWkP8
#`(exit the shell) {
  eval 'exec sidef -WkP8 $0 ${1+"$@"}'
}
##  MultiFactor, meta build system for Factor core development
##    Copyright Cat Stevens 2018
##  This program is free software: you can redistribute it and/or modify
##    it under the terms of the GNU General Public License as published by
##    the Free Software Foundation, either version 3 of the License, or
##    (at your option) any later version.
##
##    This program is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
##
##    You should have received a copy of the GNU General Public License
##    along with this program.  If not, see <https://www.gnu.org/licenses/>.
include ABCs
include argparse
include guardio
include shell_words
include withdirectory

define Hash SCRIPT = :(
  "version" => "0.3",
  "name" => "multifactor",
  "doc" => "a meta build system for Factor core development",
  "bug" => "github.com/catb0t/multifactor/issues",
  "license" => "GPL v3+"
)

# basic variable definitions for working with Factor from a high-level perspective
module Factor {
  const File RC_FILE = Dir.home+%f(.factor-rc)

  func rc_config_lines () is cached -> Array {
    Factor::RC_FILE.open_r.lines.grep{ _ ~~ /^! multifactor:.+/ }
  }

  func find_config (name, Bool must_exist = true) is cached -> String {
    const regex = Regex("^! multifactor:#{name} (.*)")
    const result = Factor::rc_config_lines().find{ _ ~~ regex }
    if (must_exist && !result) {
      die "Config 'multifactor:#{name}' not found in #{Factor::RC_FILE}"
    }
    (regex =~ result)[0]
  }

  const Dir FACTOR_DIR = Dir( Factor::find_config("factor-dir") )
  const Bool QUIET_PIPE = Bool( Factor::find_config("quiet-pipe") )

  # ???
  func say_stderr (*args) {
    if (STDOUT.is_on_tty || (!STDOUT.is_on_tty && !Factor::QUIET_PIPE)) {
      STDERR.autoflush(true)
      STDERR.say(args...)
    }
    # else, not a TTY and quiet-pipe is true
  }
}

module MultiFactor {

  include builtobj
  import builtobj::DirSum
  import builtobj::SrcSums
  import builtobj::BlobSums
  import builtobj::BuiltObj

  include Factor
  include FactorBashStateless
  include GuardIO

  func compare_properties (Array properties, BuiltObj b, Object o, Bool debug = false) {
    if (debug) {
      properties.map{
          |property|
        const db_property = b.method(property)()
        const status_property = o{property}
        say "Property '#{property}': #{db_property == status_property}: #{db_property.dump} == #{status_property.dump}"
        db_property == status_property
      }.all
    } else {
      properties.map{ |prop| b.method(prop)() } ~Z== o{properties...} -> all
    }
  }

  class Runtime (Hash options, Array factor_arguments) << ABCs2::SeriallyAccessible, withdirectory::CapturedWriter {
    has Bool _config_setup_done = false # whether the following variables have been written
    has Str _action
    has Array known_actions = ['env-info', 'src-sums', 'run-factor']

    has guardio::SLog           log
    has GuardIO::CacheDB        db_man
    has GuardIO::GlobLocker     locker
    has shell_words::FactorBash fbash

    has Bool _force
    has Bool _debug = false
    has Bool _info
    has Bool _dry_run
    has Bool _clean
    has Bool _sums
    has Bool _basis_dev

    has String _sum_blob_algo = :sha256
    has String _sum_src_algo = :sha256
    # set in config file etc, not a cmdline option
    # has Number uuid_len

    # where the process started before any chdir
    has Dir initial_wd

    has String _UUID

    -> UUID ()         { self._UUID }
    -> action          { self._action }
    -> force           { self._force }
    -> debug           { self._debug }
    -> info            { self._info }
    -> dry_run         { self._dry_run }
    -> clean           { self._clean }
    -> sums            { self._sums }
    -> basis_dev       { self._basis_dev }
    -> sum_src_algo    { self._sum_src_algo }
    -> sum_blob_algo   { self._sum_blob_algo }
    -> wd { self.initial_wd }

    -> UUID (Str u)             { self._UUID = u; self }
    -> action (Str a)           { self._action = a; self }
    -> force (Bool b)           { self._force = b; self }
    -> debug (Bool b)           { self._debug = b; self }
    -> info (Bool b)            { self._info = b; self }
    -> dry_run (Bool b)         { self._dry_run = b; self }
    -> clean (Bool b)           { self._clean = b; self }
    -> sums (Bool b)            { self._sums = b; self }
    -> basis_dev (Bool b)       { self._basis_dev = b; self }
    -> sum_src_algo (Str a)     { self._sum_src_algo = a; self }
    -> sum_blob_algo (Str a)    { self._sum_blob_algo = a; self }

    method config_setup {
      if (! self._config_setup_done) {
        self.UUID( FactorBashStateless::make_uuid(words: true) )
        self.initial_wd = Dir.cwd

        var props = Hash(
          :action => { _ },
        ).merge(
          [:force, :dry_run, :info, :clean, :sums, :basis_dev] \
            .map{ ( (_) => { Bool(_) } ) }.to_h # all these parentheses are important
        )
        props.each_kv{
            |name, convert|
          self.method( name )( convert( self.options(){ name.replace_all("_", "-") } ) )
        }

        # need a way for the consumer ofthe ArgParse API to know the exact syntax of the command line
        self.known_actions.contains(self.action) \
          || die "[FATAL] #{__FILE__, __LINE__}: #{__METHOD_NAME__}: don't know action '#{self.action}' [--action | -a]"

        # initialise helper objects

        self.log = guardio::SLog(
          is_trace: ( [:trace, :verbose, 'dry-run'].any{ self.options(){_} } ),
          is_verbose: ( [:verbose, 'dry-run'].any{ self.options(){_} } ),
          logger: { |*a| Factor::say_stderr( a... ) }
        )

        self.fbash = shell_words::FactorBash(
          Dir( self.options(){'factor-dir'} || Factor::FACTOR_DIR ), #
          subcommand_output: !( self.options(){'quiet-subcom'} || Factor::QUIET_PIPE )  #
        )

        self.db_man = GuardIO::CacheDB(
          db_base: File( self.options(){'db-name'} ),
          db_dir: Dir( self.options(){'db-dir'} ),
          dry_run: self.dry_run
        ).setup( verbose: self.options(){:verbose}, replace_existing: Bool( self.options(){'from-scratch'} ) )

        self.locker = GuardIO::GlobLocker(
          self.UUID,
          remove_old_lock: self.options(){'remove-old-lock'},
          lock_ext: '.multifactor_lock'
        ).setup( [ self.db_man.db_name, self.fbash.wd ], verbose: self.options(){:verbose} )

        self._config_setup_done = true
        self.log.trc(__FILE__, __LINE__, __METHOD_NAME__, "finished configuration") #, wd now: '#{self.db_dir}'")
      }
    }

     method show_info {}
     #  self.config_setup
     #  say "MultiFactor #{self.UUID} options"
     #  say "\tverbose: #{self.verbose}\tinfo: #{self.info}\ttrace: #{self.trace}\tdry_run: #{self.dry_run}"
     #  say "\tclean: #{self.clean}\tsums: #{self.sums}\tdb_name: #{self.db_name}\tdb_path: #{self.db_path}"
     #  say "\tfactor_path: #{self.factor_path}\tdb: #{self.db}\tremove_old_lock: #{self.remove_old_lock}"
     #  say "\tFactor arguments: #{self.factor_arguments}"
     #}

    -> _blob_file_contents_sum (File f, Str algo) {
      # self.log.vbs(__FILE__, __LINE__, __METHOD_NAME__, "checksumming #{f} with algorithm '#{algo}'")
      # give checksum of empty file, or die?
      self.fbash.with_directory{
        (f.exists && BuildSh::blob_file_contents_sum(f, algo || self.sum_blob_algo)) \
          || die "[FATAL] #{__METHOD_NAME__}: empty algo: file: #{f}"
      }
    }

    -> current_status_to_builtobj (Hash status) -> BuiltObj {
      self.log.vbs(__FILE__, __LINE__, __METHOD_NAME__, 'creating BuiltObj from scratch')
      var bo = BuiltObj().id(self.UUID)
      status.keys.each{
          |prop|
        # self.vbs(__FILE__, __LINE__, __METHOD_NAME__, "invoke method / property '#{prop}'")
        bo.method(prop)( status{prop} )
      }
      self.log.vbs(__FILE__, __LINE__, __METHOD_NAME__, 'setting creation time')
      bo.time_created(Time.now)
    }

    -> _compile_vm_lib (BuiltObj bo) {
      if ( ! self.fbash.build_factor(bo) ) {
        self.locker.cleanup
        die "vm compilation failed!"
      }
      self.log.vbs(__FILE__, __LINE__, __METHOD_NAME__, "vm/lib compiled")
      true
    }

    -> compile_vm_lib (BuiltObj bo, String caller_name = "") -> Bool {
      # no double jeopardy; technically redundant but that's okay
      if (caller_name == :maybe_recompile_target) {
        static var have_compiled = false
        if (! have_compiled) {
          self.log.vbs(__FILE__, __LINE__, __METHOD_NAME__, "vm/lib compiling for 1st time")
          self._compile_vm_lib(bo)
          have_compiled = true
        } else {
          self.log.vbs(__FILE__, __LINE__, __METHOD_NAME__, "vm/lib not recompiled: #{caller_name}: no double jeopardy")
        }
        true
      } else { self._compile_vm_lib(bo) }
    }
    -> compile_vm (o, c)  { self.compile_vm_lib(o, caller_name: c) }
    -> compile_lib (o, c) { self.compile_vm_lib(o, caller_name: c) }

    -> compile_image (BuiltObj bo) -> Bool {
      if (! self.fbash.build_image(bo) ) {
        self.locker.cleanup
        die "image compilation failed!"
      }
      self.log.vbs(__FILE__, __LINE__, __METHOD_NAME__, "image compiled")
      true
    }

    # NOTE: modifies obj
    -> sum_save_boot_image (BuiltObj bo) {
      self.log.trc(__FILE__, __LINE__, __METHOD_NAME__, "saving boot image sums for #{bo.boot_fullname}")
      const disk_sum_toplevel = self._blob_file_contents_sum(bo.boot_fullname, bo.blob_algorithm)

      if ( disk_sum_toplevel != bo.blob_sums.boot ) {
        bo.blob_sums( BlobSums(
          algo: bo.blob_algorithm || self.sum_blob_algo,
          boot: disk_sum_toplevel,
          # set the rest of the properties to their old values
          [:vm, :lib].map{
              |n|
            n ¦ bo.blob_sums.method(n)
          }...
        ))
      }

      const disk_sum_stored = self._blob_file_contents_sum(bo.boot_fullname, bo.stored_boot_image(){:algo})

      if ( disk_sum_stored != bo.stored_boot_image(){:sum} ) {
        bo.stored_boot_image(Hash(
          :sum => disk_sum_stored,
          :data => self.fbash.with_directory{ FactorBashStateless::read_binary_b64(bo.boot_fullname) },
          :algo => bo.stored_boot_image(){:algo} || bo.blob_algorithm || self.sum_blob_algo
        ))
      }
    }

    # complex check for vm and lib
    -> maybe_recompile_target (BuiltObj match_bo, /* BlobSums */ cur_blob_sums, String target, /* Hash */ previous_recompiled) {
      const MN = __METHOD_NAME__
      ((target) => match_bo.method(target + :_fullname)().cleave({
          |target_fullname|
        (false == previous_recompiled{target})
        ? false
        : if (
          match_bo.cleave({ # cleave as "let"
              |b|
            self.fbash.with_directory{
              const exists = target_fullname.exists
              const disk_sum = self._blob_file_contents_sum( target_fullname, b.blob_algorithm )
              const matched_sum = b.blob_sums.method(target)()
              const sum_indirect = (defined(cur_blob_sums)
                ? ( b.blob_sums.method(target)() =~ cur_blob_sums.method(target)() )
                : nil)
              (! exists) || ((disk_sum != matched_sum) && (sum_indirect == false))
            }
          }).last
        ) {
          self.log.trc(__FILE__, __LINE__, MN, "NOT EXIST/MATCH #{target} named '#{target_fullname}' rebuilding")
          self.method(:compile_ + target)(match_bo, __METHOD_NAME__)
          # true
        } else {
          self.log.vbs(__FILE__, __LINE__, MN, "EXIST+MATCH #{target} named '#{target_fullname}' not rebuilding")
          false
        }
      }).last)
    }

    -> _make_disk_blob_sums (BuiltObj bo, Array targets) {
      self.fbash.with_directory{
        BlobSums(
          algo: self.sum_blob_algo,
          targets.map{
              |target|
            ( target ¦ self._blob_file_contents_sum( bo.method(target + :_fullname)(), bo.blob_algorithm ) )
          }...
        )
      }
    }

    -> build_new_factor (Hash current_status) {
      const MN = __METHOD_NAME__

      self.log.trc(__FILE__, __LINE__, MN, 'no match in db!')
      # interpret the current_status keys as property (setter) names in BuiltObj
      # this call does not set all properties, only those listed in status_properties
      return self.current_status_to_builtobj(current_status).cleave(
        { |n| self.compile_vm_lib(n) },
        { |n| self.compile_image(n)  },
        { |n| n.blob_sums( self._make_disk_blob_sums(n, [:vm, :lib, :boot]) ) },
        { |n| self.sum_save_boot_image(n) }, # modifies n
        { .lock },
        { self.log.trc(__FILE__, __LINE__, MN, 'writing the new BuiltObj to disk db because it changed') },
        { self.db_man.insert(_) },
        { self.log.trc(__FILE__, __LINE__, MN, "ok, running factor!") },
        { self.locker.cleanup },
        { self._detach_factor_thread(_.vm_fullname) }
      )
    }

    -> _tombstone_entry (BuiltObj bo, Array tracked_targets) {
      const tombstoning = (bo |> :dclone |> :unlock)
      del bo
      tombstoning.time_tombstoned(Time.now)

      self.db_man.insert(tombstoning)
      self.capture_write_disk(__METHOD_NAME__, { tracked_targets.each{ tombstoning.method(_ + :_fullname)().remove } } )
    }

    # multifactor's actual entry point
    # TODO: make this asynchronous, so that with_directory stuff is
    # done in a separate actor and awaited

    # DONE: dynamic hash algo selection
    # TODO: read mtimes
    # TODO: test whether the images are older than the file mtimes?!
    # TODO: write mtime/atimes
    # TODO: testability
    # DONE: if branches
    # DONE: make use of git information
    # DONE: compare OS, ARCH, WORD SIZE information
    # TODO: image compression?

    #TDOO: DON"T HASH FACTOR IMAGE
    method go (Bool is_restart = false) {
      const MN = __METHOD_NAME__
      self.config_setup
      if (self.info) { self.show_info; return nil }

      self.locker.do_lock_files

      given (self.action) {
        when ('src-sums') {
          self.fbash.say_src_sums
          return self.locker.cleanup
        }
        when ('env-info') {
          self.fbash.say_env_info
          return self.locker.cleanup
        }
      }

      # property names in BuiltObj, used to create current_status
      # BuildSh and FactorBash implement these through FactorBash.delegate
      const status_properties = [
        :factor_version, :is_git, :git_branch, :git_hash,
        :os_type, :os_name, :arch_name, :word_size,
        # these defaults are kinda pointless
        [ :vm_format,    default: { [ '', :fvm_, BuildSh::platform_vm_ext() ] } ],
        [ :image_format, default: { [ '', :fvm_, '.image' ] } ],
        [ :lib_format,   default: { [ BuildSh::platform_lib_name()..., :fvm_].swap(-2, -1) } ],
        [ :boot_format,  default: { [ 'boot.', :fvm_, '.image' ] } ]
        # the block is called for its default value but without arguments,
        #   because a "normal" version of the :sum_algorithm method in FactorBash
        #   requires knowledge of its containing class
        # this allows setting the blob checksum algorithm from the command line arguments
        [ :blob_algorithm, default: { self.sum_blob_algo } ],
        # this allows setting the SrcSums checksum algorithm for the VM on the command line
        [ :src_sums, args: [self.sum_src_algo, self.basis_dev] ],
      ]
      subset ArrStr < String, Array
      # makes Array<String, default?, args?> into String
      -> undefault_single (prop < ArrStr) -> String { [@|prop] -> first }
      # makes Array<Array<String, default?, args?>> into Array<String>
      -> undefault (Array props) -> Array { props.map{ undefault_single(_) } }

      # current_status is a Hash representing current disk / system config
      # it maps string property names in status_properties to the result of
      #   determining their values through FactorBash.delegate
      # '@|' is like '...' but only calls '...' when the object can recieve it
      const current_status = status_properties.map{ |n| (undefault_single(n), self.fbash.delegate(@|n)) }.to_h
      const db_data = self.db_man.load
      if (self.debug) {
        say current_status
        say db_data
      }

      # compare_properties just wants the Array<String> as its basis for
      #   comparing properties
      # we're done with the status_properties Array<String, default?, args?>
      #  now but it may come in handy
      const match_bo = db_data.values.find{
        |b|
        # remember, we're not testing *all* properties like .lock or tombstoned
        MultiFactor::compare_properties(undefault(status_properties), b, current_status, debug: self.debug)
      }

      # need to generate new ID and compile
      if (! match_bo) { return self.build_new_factor(current_status) }

      # now this is definitely defined
      match_bo.lock
      define tracked_targets = [:vm, :lib]

      if (match_bo.time_tombstoned != 'never') {
        say '!!! matching entry is tombstoned!'
        # need to trash the old entry
        self._tombstone_entry(match_bo, tracked_targets)
        return self.build_new_factor(current_status)
      }

      self.log.vbs(__FILE__, __LINE__, MN, 'matching object in db')


      -> do_recompile_needed (BlobSums cur_blob_sums = nil, Hash previous_recompiled = nil) -> Hash {
        [
          tracked_targets.map{ self.maybe_recompile_target(match_bo, cur_blob_sums, _, previous_recompiled) }...,
          :image => (
            (false == previous_recompiled{:image} )
              ? false
              : self.fbash.with_directory{ match_bo.image_fullname.exists ? false : self.compile_image(match_bo) }
            )
        ].to_h
      }

      self.log.vbs(__FILE__, __LINE__, MN, "NOTE: no checksums in main path yet")
      # ...
      var (
        new_recompiled = do_recompile_needed(),
        current_blob_sums = self._make_disk_blob_sums(match_bo, tracked_targets)
      )
      # self.log.vbs(__FILE__, __LINE__, MN, "NOTE: ONCE: #{new_recompiled}")

      new_recompiled = do_recompile_needed(cur_blob_sums: current_blob_sums, previous_recompiled: new_recompiled)
      current_blob_sums = (new_recompiled.values.all{ !_ }
        ? current_blob_sums
        : self._make_disk_blob_sums(match_bo, tracked_targets))

      # self.log.vbs(__FILE__, __LINE__, MN, "NOTE: TWICE: #{new_recompiled}")
      self.log.trc(__FILE__, __LINE__, MN, "done calculating checksums / rebuilding")

      # if they STILL don't match, delete the files + tombstone the entry and quit
      if ( ! (current_blob_sums =~ match_bo.blob_sums) ) {
        self.log.trc(__FILE__, __LINE__, MN, 'blob sums still mismatched!')
        if (is_restart) {
          self.log.trc(__FILE__, __LINE__, MN, "i give up (already in a restart)")
          return self.locker.cleanup
        }
        self.log.trc(__FILE__, __LINE__, MN, "starting over...")
        self._tombstone_entry(match_bo, tracked_targets)
        return self.go(is_restart: true)
      }

      # OK, going to update the DB and run Factor

      # only updating the blob sums IFF the blob was newly compiled
      # otherwise, just update the mod/access times and run count
      const new_match_bo = match_bo.cleave( { .lock }, { .dclone } ).last
      if ( [ new_recompiled{ tracked_targets... } ].any{ _ == true } ) {
        self.log.vbs(__FILE__, __LINE__, MN, 'writing memory BuiltObj because of the newly compiled VM')
        new_match_bo.blob_sums(current_blob_sums)
        new_match_bo.time_modified(Time.now)
      }

      new_match_bo.lock

      # ?????
      const changed_db = if (match_bo != new_match_bo) {
        self.log.trc(__FILE__, __LINE__, MN, 'writing the new BuiltObj to disk db because it changed')
        self.db_insert(new_match_bo)
        true
      }

      # say "Eventual successful configuration!"
      # say "\tmatching_vm_name:\t'#{matching_vm_name}' # #{disk_vm_sum[0..10]}...\tmatching_image_name:\t'#{matching_image_name}' #{disk_image_sum[0..10]}..."
      # say "\tvm_sums_match:\t\t#{vm_blob_sums_match}/#{new_vm_blob_sums_match}"
      # say "\timage_sums_match:\t#{image_blob_sums_match}/#{new_image_blob_sums_match}"
      # say "\tchanged_db:\t\t#{changed_db}\t\t\tnewly_compiled: #{newly_compiled.to_s.chars.grep{|p|![\"\n\",' '].any{p==_} }.join}"
      self.log.trc(__FILE__, __LINE__, MN, "ok, running factor!")
      self.locker.cleanup
      self._detach_factor_thread(match_bo.vm_fullname)
    }

    -> _detach_factor_thread (String vm_name) {
      const MN = __METHOD_NAME__
      {
        self.log.inf(__FILE__, __LINE__, MN, 'Launching Factor: ', "'", vm_name, self.factor_arguments..., "'")
        if ( ! self.fbash.with_directory{
            Command::spawn_se('./' + vm_name, self.factor_arguments..., output: false)
        } ) {
          self.log.inf(__FILE__, __LINE__, MN, "Failed: #{$!}")
        }
      }.thr.detach
      # don't segfault
    }
  }
}

define MICRO_MAGNITUDE = 1_000
func μsec { Time.micro*MICRO_MAGNITUDE }
func μsec (Number n) { Time.micro*MICRO_MAGNITUDE - n }

func main {
  const μs = μsec()
  μs
  # say Factor::RC_FILE
  # say Factor::REPO
  # say Factor::VERSION
  # say Dir.cwd
  # say Dir.cwd
  # Dir.chdir(Factor::REPO)
  # say BuildSh::generate_make_targets()
  # say FactorBash::sum_git_names_matching(/\.s(?:m|f)/)
  # say FactorBash::sum_git_contents_matching(/\.s(?:m|f)/)
  # say MultiFactor::BuiltObj(([""] * 15)..., false ).dump.len

  const parser = argparse::ArgParse(ARGV) \
    .info(SCRIPT) \
    .option("force", :f, doc: "Force a rebuild in any case") \
    .option("trace", :t, doc: "Some debug tracing") \
    .option("verbose", :V, doc: "Verbose debug tracing") \
    .option("info", :i, doc: "Just show configuration information") \
    .option("dry-run", :n, doc: "Change no disk files") \
    .option("from-scratch", :g, doc: "ignore existing DB (debug)") \
    .option("sums", :s,  negate: "Always":"Never", doc: "use checksums") \

    .option("db-name", :D, param: "name":".multifactor.db", doc: "Custom database filename") \
    .option("db-dir", :d, param: "dir":".", doc: "Directory containing database") \
    .option("factor-dir", :w, param: "dir":".", doc: "Path to Factor working directory") \
    .option("remove-old-lock", :R, doc: "Blindly remove any lock files (unsafe!)") \
    .option("quiet-subcom", :q, negate: "Never":"Always", doc: "show subcommand outputs") \
    # TODO: argparse can accept a list of allowed values
    .option(
      "action", "a", param: "name":"run-factor",
      doc: "Perform this action\nactions: run-factor, src-sums, env-info"
    ) \
    .option("basis-dev", :b, doc: "Ignore changes in basis/\n(basis development mode)") \
    .use_option_terminator("Further arguments are given to Factor") \
    # .use_stdin_file_arg \
    # .use_arg_list_terminator \
    # .ignore_unknowns \
    # .help_on_stderr \
    .arg("arg...", doc: "Arguments to the final Factor VM")

  var (opts, args, *_) = parser.go...
  # say "#{opts} #{args} #{_}"

  const r = MultiFactor::Runtime(opts, args.keys)

  # r.show_info()
  r.go()

  Factor::say_stderr("\n\tΔ#{μsec(μs)} ×1,000μ")
}

if (__FILE__ == __MAIN__) {
  main()
}
