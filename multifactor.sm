#! sidef -vWkP8
#`(exit the shell) {
  eval 'exec sidef -WkP8 $0 ${1+"$@"}'
}
##  MultiFactor, meta build system for Factor core development
##    Copyright Cat Stevens 2018
##  This program is free software: you can redistribute it and/or modify
##    it under the terms of the GNU General Public License as published by
##    the Free Software Foundation, either version 3 of the License, or
##    (at your option) any later version.
##
##    This program is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
##
##    You should have received a copy of the GNU General Public License
##    along with this program.  If not, see <https://www.gnu.org/licenses/>.
class Object {
  method cleave (*blocks) {
    blocks.map{ .run(self) } # ...
  }
  method ifold (*bv_pairs) {
    bv_pairs.map{ |p| p.first.run( self, @(p.second)... ) }
  }
}

include argparse
include shell_words

define Hash SCRIPT = :(
  "version" => "0.3",
  "name" => "multifactor",
  "doc" => "a meta build system for Factor core development",
  "bug" => "github.com/catb0t/multifactor/issues",
  "license" => "GPL v3+"
)

# basic variable definitions for working with Factor from a high-level perspective
module Factor {
  const File RC_FILE = Dir.home+%f(.factor-rc)

  func rc_config_lines () is cached -> Array {
    Factor::RC_FILE.open_r.lines.grep{ _ ~~ /^! multifactor:.+/ }
  }

  func find_config (name, Bool must_exist = true) is cached -> String {
    const regex = Regex("^! multifactor:#{name} (.*)")
    const result = Factor::rc_config_lines().find{ _ ~~ regex }
    if (must_exist && !result) {
      die "Config 'multifactor:#{name}' not found in #{Factor::RC_FILE}"
    }
    (regex =~ result)[0]
  }

  const Dir FOLDER = Dir(Factor::find_config("factor-dir"))
  const Bool QUIET_PIPE = Bool(Factor::find_config("quiet-pipe"))

  # ???
  func say_stderr (*args) {
    if (STDOUT.is_on_tty || (!STDOUT.is_on_tty && !Factor::QUIET_PIPE)) {
      STDERR.autoflush(true)
      STDERR.say(args...)
    }
    # else, not a TTY and quiet-pipe is true
  }
}

module MultiFactor {
  import shell_words::DirSum
  import shell_words::SrcSums
  import shell_words::BlobSums

  class TimeSpec {}

  # i would like for this to be a struct but accessors are a necessity
  class BuiltObj (
    Str  _id = '',             # long uuid
    Str  _factor_version = '', # 0.98, 0.99
    Bool _is_git = true,       # whether it's in a git repository
    Str  _git_branch = '',     # branch to which this applies
    Str  _git_hash = '',       # hash it's from; git rev-parse HEAD

    Str  _os_type = '',   # target os kind
    Str  _os_name = '',   # specific os string
    Str  _arch_name = '', # x86 / ppc / arm ...
    Str  _word_size = '', # 32 / 64

    # a boot image stored in the database, for emergencies
    Hash _stored_boot_image = Hash(:data => '', :algo => '', :sum => ''),

    SrcSums  _src_sums = SrcSums(),     # .
    BlobSums _blob_sums = BlobSums(),   # .
    Str      _blob_algorithm = :sha256, # usually sha256

    Num  _time_created = 0,         # epoch timestamp
    Num  _time_modified = 0,        # .
    Num  _time_accessed = 0,        # .
    Str  _time_tombstoned = :never, # for once-existing now-deleted images; stores deletion time

    # this is probably dumb but they should all be the same length and support platform-prefixes
    Array _vm_format = [],    # length: 3
    Array _image_format = [], # length: 3
    Array _lib_format = [],   # length: 3
    Array _boot_format = [],  # length: 3

    Bool _lk = false,               # object locking
    Str  _fail = 'attempted writing to locked BuiltObj object!'
  ) {
    -> lock () -> BuiltObj { self._lk = true; self }
    -> unlock () -> BuiltObj { self._lk = false; self }

    -> id () -> Str { self._id }
    -> factor_version () -> Str { self._factor_version }

    -> is_git () -> Bool { self._is_git }
    -> git_branch () -> Str { self._git_branch }
    -> git_hash () -> Str { self._git_hash }

    -> os_type () -> Str { self._os_type }
    -> os_name () -> Str { self._os_name }
    -> arch_name () -> Str { self._arch_name }
    -> word_size () -> Str { self._word_size }

    -> src_sums () -> SrcSums { self._src_sums }
    -> blob_sums () -> BlobSums { self._blob_sums }
    -> blob_algorithm () -> Str { self._blob_sums.algo || self._blob_algorithm }

    -> vm_format () -> Array { self._vm_format }
    -> image_format () -> Array { self._image_format }
    -> lib_format () -> Array { self._lib_format }
    -> boot_format () -> Array { self._boot_format }

    # move into TimeSpec
    -> time_created () -> Num { self._time_created }
    -> time_modified () -> Str { self._time_modified }
    -> time_accessed () -> Str { self._time_access }
    -> time_tombstoned () -> Str { self._time_tombstoned }

    -> stored_boot_image () -> Str { self._stored_boot_image }

    -> id (Str i)             { die self._fail if (self._lk); self._id = i            ; self }
    -> factor_version (Str v) { die self._fail if (self._lk); self._factor_version = v; self }

    -> is_git (Bool g)    { die self._fail if (self._lk); self._is_git = g    ; self }
    -> git_branch (Str b) { die self._fail if (self._lk); self._git_branch = b; self }
    -> git_hash (Str h)   { die self._fail if (self._lk); self._git_hash = h  ; self }

    -> os_type (Str t)   { die self._fail if (self._lk); self._os_type = t  ; self }
    -> os_name (Str n)   { die self._fail if (self._lk); self._os_name = n  ; self }
    -> arch_name (Str a) { die self._fail if (self._lk); self._arch_name = a; self }
    -> word_size (Str w) { die self._fail if (self._lk); self._word_size = w; self }

    -> src_sums (SrcSums s)   { die self._fail if (self._lk); self._src_sums = s      ; self }
    -> blob_sums (BlobSums b) { die self._fail if (self._lk); self._blob_sums = b     ; self }
    -> blob_algorithm (Str s) { die self._fail if (self._lk); self._blob_algorithm = s; self }

    -> vm_format (Array a)    { die self._fail if (self._lk); self._vm_format = a   ; self }
    -> image_format (Array a) { die self._fail if (self._lk); self._image_format = a; self }
    -> lib_format (Array a)   { die self._fail if (self._lk); self._lib_format = a  ; self }
    -> boot_format (Array a)  { die self._fail if (self._lk); self._boot_format = a  ; self }

    -> time_created (Num x)    { die self._fail if (self._lk); self._time_created = x   ; self }
    -> time_modified (Str x)   { die self._fail if (self._lk); self._time_modified = x  ; self }
    -> time_accessed (Str x)   { die self._fail if (self._lk); self._time_access = x    ; self }
    -> time_tombstoned (Str x) { die self._fail if (self._lk); self._time_tombstoned = x; self }

    -> stored_boot_image (Hash b) { die self._fail if (self._lk); self._stored_boot_image = b; self }

    # want a version of insert that doesn't change its object unless ! is used
    -> vm_fullname ()    -> File { File( "#{self.vm_format[0, 1]}#{self.id}#{self.vm_format[2]}" ) }
    -> image_fullname () -> File { File( "#{self.image_format[0, 1]}#{self.id}#{self.image_format[2]}" ) }
    -> lib_fullname ()   -> File { File( "#{self.lib_format[0, 1]}#{self.id}#{self.lib_format[2]}" ) }
    -> boot_fullname ()  -> File { File( "#{self.boot_format[0, 1]}#{self.id}#{self.boot_format[2]}" ) }
  }

  include Factor
  include FactorBashStateless

  define String temp_read_ext = "\.tmp_read_"
  define String temp_write_ext = "\.tmp_write_"

  -> temp_read_target (File name) is cached -> File {
    File(name + MultiFactor::temp_read_ext + FactorBashStateless::make_uuid(words: false) )
  }
  -> temp_write_target (File name) is cached -> File {
    File(name + MultiFactor::temp_write_ext + FactorBashStateless::make_uuid(words: false) )
  }

  # NOTE: NOT instance-specific, i.e doesn't use *OUR* UUID in name
  # this copies a file to a temporary for reading
  func temp_r (File name) -> File {
    die "Cannot stat #{name}" if (! name.exists)
    const File target = MultiFactor::temp_read_target(name)
    if (! name.copy(target) ) {
      die "Can't copy file #{name} to #{target}: #{$!}"
    }
    target
  }
  # this makes a temp file for writing, which can be rename()d over `name`
  func temp_w (File name) -> File {
    const File target = MultiFactor::temp_write_target(name)
    if (target.exists) {
      die "Create file #{target}: file exists"
    }
    target
  }
  # argument is used literally
  func finalise_temp_r (File target) {
    die "Cannot stat #{target}" if (! target.exists)
    if (! target.remove) {
      die "Can't remove #{target}: #{$!}"
    }
  }
  # requires literal arguments due to UUID
  func finalise_temp_w (File name, File target) {
    die "Cannot stat #{target}" if (! target.exists)
    if (! target.move(name)) {
      die "Can't move #{target} over #{name}: #{$!}"
    }
  }

  # these are actually the interfaces to the above words
  # this returns a filehandle to in-memory string
  func atomic_read (File name) -> String {
    const File tmp = MultiFactor::temp_r(name)
    const tmp_fh = tmp.open_r
    die "Couldn't open file for reading: #{tmp}: #{$!}" if (! tmp_fh)
    const String contents = tmp_fh.slurp
    die "Read file '#{tmp}' failed: #{$!}" if (! defined(contents))
    contents # won't be eagerly evaluated (will be nil) without this line
    # check error here?
    tmp_fh.close
    MultiFactor::finalise_temp_r(tmp)
    contents
  }
  func atomic_write (File name, String contents) {
    const File tmp = MultiFactor::temp_w(name)
    const tmp_fh = tmp.open_w
    die "Couldn't open file for writing: #{tmp}: #{$!}" if (! tmp_fh)
    const Bool res = tmp_fh.spurt(contents)
    die "Couldn't write #{contents.len} bytes to #{tmp}: #{$!}" if (! res)
    tmp_fh.close
    MultiFactor::finalise_temp_w(name, tmp)
    return nil
  }

  func _read_disk_db (File name) is cached -> Hash {
    # look for the database file
    # if it doesn't exist, stop
    # otherwise, open it
    const contents = MultiFactor::atomic_read(name)
    # if it's empty, get a new one -> []
    if (! contents) {
      return Hash()
    }
    const eval_contents = eval(contents)
    # if it's not empty, but contains invalid / throwing code, THAT's an error!
    if (! defined(eval_contents)) {
      die "Malformed db: #{name} (it failed to eval): #{contents}"
    }
    # if it contains only [], it's also empty -> []
    if (! eval_contents) {
      return Hash()
    }
    # if it contains [BuiltObj()...], it's nonempty -> [BuiltObj()...]
    eval_contents.values.all{ .is_a(BuiltObj) } || die "Found garbage in #{name}: #{contents}"
    return eval_contents
  }

  func _write_disk_db (File name, Hash new_data) {
    const String new_contents = new_data.dump # safe ???
    # look for the database file
    # if it doesn't exist, stop
    # otherwise, open it
    MultiFactor::atomic_write(name, new_contents)
  }

  func compare_properties (Array properties, BuiltObj b, Object o, Bool debug = false) {
    if (debug) {
      properties.map{
          |property|
        const db_property = b.method(property)()
        const status_property = o{property}
        say "Property '#{property}': #{db_property == status_property}: #{db_property.dump} == #{status_property.dump}"
        db_property == status_property
      }.all{ _ }
    } else {
      properties.map{ |prop| b.method(prop)() } ~Z== o{properties...} -> all{ _ }
    }
  }

  # ellipsify absolute path
  func _bn (File name) -> String { '.../'+Dir(name.dir.basename)+File(name.basename) }

  class Runtime (Hash options, Array factor_arguments) {
    has Bool _config_setup_done = false # whether the following variables have been written
    has Str _lock_ext = '.multifactor_lock'
    has Str _action
    has Array known_actions = ['env-info', 'src-sums']

    has Array db_changes # tracking order of reads/writes
    has Set locked_fods

    has Bool _force
    has Bool _trace
    has Bool _verbose
    has Bool _debug = false
    has Bool _info
    has Bool _dry_run
    has Bool _clean
    has Bool _sums
    has Bool _remove_old_lock
    has Bool _basis_dev

    has String _sum_blob_algo = :sha256
    has String _sum_src_algo = :sha256
    # set in config file etc, not a cmdline option
    # has Number uuid_len

    # where the process started before any chdir
    has Dir initial_wd

    has shell_words::FactorBash fbash

    has Dir  _factor_dir
    has Dir  _db_path
    has File _db_name

    has String _UUID

    -> UUID ()         { self._UUID }
    -> lock_ext        { self._lock_ext }
    -> action          { self._action }
    -> force           { self._force }
    -> trace           { self._trace }
    -> verbose         { self._verbose }
    -> debug           { self._debug }
    -> info            { self._info }
    -> dry_run         { self._dry_run }
    -> clean           { self._clean }
    -> sums            { self._sums }
    -> remove_old_lock { self._remove_old_lock }
    -> basis_dev       { self._basis_dev }
    -> sum_src_algo    { self._sum_src_algo }
    -> sum_blob_algo   { self._sum_blob_algo }
    -> factor_dir      { self._factor_dir }
    -> db_path         { self._db_path }
    -> db_name         { self._db_name }
    -> db { self._db_path+self._db_name }

    -> UUID (Str u)             { self._UUID = u; self }
    -> lock_ext (Str e)         { self._lock_ext = e; self }
    -> action (Str a)           { self._action = a; self }
    -> force (Bool b)           { self._force = b; self }
    -> trace (Bool b)           { self._trace = b; self }
    -> verbose (Bool b)         { self._verbose = b; self }
    -> debug (Bool b)           { self._debug = b; self }
    -> info (Bool b)            { self._info = b; self }
    -> dry_run (Bool b)         { self._dry_run = b; self }
    -> clean (Bool b)           { self._clean = b; self }
    -> sums (Bool b)            { self._sums = b; self }
    -> remove_old_lock (Bool b) { self._remove_old_lock = b; self }
    -> basis_dev (Bool b)       { self._basis_dev = b; self }
    -> sum_src_algo (Str a)     { self._sum_src_algo = a; self }
    -> sum_blob_algo (Str a)    { self._sum_blob_algo = a; self }
    -> factor_dir (Dir d)       { self._factor_dir = d; self }
    -> db_path (Dir d)          { self._db_path = d; self }
    -> db_name (File d)         { self._db_name = d; self }

    -> _log (*a) { Factor::say_stderr(a...) }
    -> wrn (Num l, Str m, *args) { say "[WARN]\t#{l}: #{m}: #{args.join(' ')}" }
    -> inf (Num l, Str m, *args) { self._log("[INFO]\t", l, ': ', m, ': ', args.join(' ')) }
    -> trc (Num l, Str m, *args) { self._log("[TRACE]\t", l, ': ', m, ': ', args.join(' ')) if (self.trace) }
    -> vbs (Num l, Str m, *args) { self._log("[VBOSE]\t", l, ': ', m, ': ', args.join(' ')) if (self.verbose) }
    # more verbose than trace ^^^

    method config_setup {
      if (! self._config_setup_done) {
        self.UUID( FactorBashStateless::make_uuid(words: true) )
        self.initial_wd = Dir.cwd

        var props = Hash(
          :db_name => { File(_) },
          :db_path => { Dir(_) },
          :factor_dir => { Dir(_) },
          :action => { _ },
        ).merge(
          [:force, :dry_run, :verbose, :trace, :info, :clean, :sums, :remove_old_lock, :basis_dev] \
            .map{ (_) => { Bool(_) } }.to_h
        )

        props.each_kv{
            |name, convert|
          self.method( name )( convert( self.options(){ name.replace_all("_", "-") } ) )
        }
        self.verbose(self.verbose || self.dry_run)
        self.trace(self.trace || self.dry_run || self.verbose)

        # need a way for the consumer ofthe ArgParse API to know the exact syntax of the command line
        self.known_actions.contains(self.action) \
          || die "[FATAL] #{__LINE__}: #{__METHOD_NAME__}: don't know action '#{self.action}' [--action | -a]"

        self.fbash = shell_words::FactorBash(
          self.factor_dir,
          subcommand_output: Bool( ! self.options\{'quiet-subcom'} )
        )

        if (self.remove_old_lock) {
          self.wrn(__LINE__, __METHOD_NAME__, "!!!", "blindly removing old lockfiles (unsafe/debug) [--remove-old-lock | -R]")
        }

        self.locked_fods = Set(self.db, self.factor_dir).map{ .abs.realpath }

        self._config_setup_done = true
        self.trc(__LINE__, __METHOD_NAME__, "finished configuration, wd now: '#{self.db_path}'")
      }
    }

     method show_info {}
     #  self.config_setup
     #  say "MultiFactor #{self.UUID} options"
     #  say "\tverbose: #{self.verbose}\tinfo: #{self.info}\ttrace: #{self.trace}\tdry_run: #{self.dry_run}"
     #  say "\tclean: #{self.clean}\tsums: #{self.sums}\tdb_name: #{self.db_name}\tdb_path: #{self.db_path}"
     #  say "\tfactor_path: #{self.factor_path}\tdb: #{self.db}\tremove_old_lock: #{self.remove_old_lock}"
     #  say "\tFactor arguments: #{self.factor_arguments}"
     #}

    method capture_write_disk (String caller_name, Block operation) {
      if (! self.dry_run) {
        self.vbs(__LINE__, __METHOD_NAME__, "#{caller_name}: writing disk with", operation)
        return operation.run
      }
      self.vbs(__LINE__, __METHOD_NAME__, "#{caller_name}: not writing disk (dry run)")
      nil
    }

    method read_disk_db () is cached -> Hash {
      self.config_setup
      self.trc(__LINE__, __METHOD_NAME__, 'reading', self.db)

      MultiFactor::_read_disk_db(self.db)
    }

    method load_db () is cached -> Hash {
      self.vbs(__LINE__, __METHOD_NAME__, 'loading db...')
      static const db_data
      if (! defined(db_data)) {
        self.vbs(__LINE__, __METHOD_NAME__, 'wasn\'t cached!')
        db_data = self.read_disk_db
      }
      db_data
    }

    method write_disk_db (Hash new_data) {
      const MN = __METHOD_NAME__
      self.config_setup
      self.trc(__LINE__, MN, 'writing', self.db)

      if ( defined(new_data) && Bool(new_data) && new_data.values.all{_ ~~ BuiltObj} ) {
        self.capture_write_disk(MN, { MultiFactor::_write_disk_db(self.db, new_data) } ) #, __METHOD_NAME__ )
      } else {
        self.cleanup_lock_files
        die "[ERROR]\t#{__METHOD_NAME__}: garbage argument #{new_data}"
      }
    }

    # TODO: don't write the disk right away
    method db_insert (BuiltObj new_entry) {
      self.trc(__LINE__, __METHOD_NAME__, 'inserting', new_entry)
      const entire_db = self.load_db
      entire_db{new_entry.id} = new_entry
      self.write_disk_db( entire_db )
    }

    method db_delete (String id) {
      self.trc(__LINE__, __METHOD_NAME__, 'removing id \'', id, "'")
      const entire_db = self.load_db
      entire_db.delete(id)
      self.write_disk_db( entire_db )
    }


    -> _glue_absolute (t) is cached -> File {
      const File lock_file = File(t + self.lock_ext) # expecting t to be absolute

      die "[BUG]\t#{__METHOD_NAME__}: didn't create an absolute path by gluing '#{t}' and '#{self.lock_ext}': #{lock_file}" \
        if (! lock_file.is_abs)
      lock_file
    }

    -> _lock_exists (target, Bool cleanup) {
      const MN = __METHOD_NAME__
      const lock_file = self._glue_absolute(target)

      const Str contents = MultiFactor::atomic_read(lock_file).chomp
      die "[ERROR]\t#{MN}: empty lockfile for target '#{target}'; not safe to continue" \
        if (! contents)

      if (contents == self.UUID) {
        if (! cleanup) {
          die ("[BUG]\t #{MN}: lock file '#{lock_file}' for " +
            "target '#{target}' contains the current process' UUID" +
            "\n\tUnnecessary read; MultiFactor bug found! in #{target.basename}")
        }
        lock_file.remove
        self.vbs(__LINE__, MN, "cleaned up #{_bn(lock_file)}")
      } else {
        self.vbs(__LINE__, MN, "!! UUID mismatch: #{contents} ≠ #{self.UUID}")
        die (
          "[ERROR]\t#{MN}: lock file '#{lock_file}' for target '#{target}' contains foreign UUID!" +
          "\n\t(only one MultiFactor process should be active in a directory)" +
          "\n\tnot removing it; not continuing"
        )
      }
    }

    -> _do_remove_old_lock {
      if (self.remove_old_lock) {
        self.locked_fods.each{
          const lf = self._glue_absolute(_)
          self.vbs(__LINE__, __METHOD_NAME__, "try to clear old lock file #{_bn(lf)}")
          lf.exists && (
            lf.remove || self.wrn(__LINE__, __METHOD_NAME__, "can't remove #{lf} for an unknown reason: #{$!}")
          )
        }
      }
    }

    # NOTE: this ensures "we are a running process and we must be the only such running process"
    -> _do_lock_file (target, Bool cleanup) {

      die "[ERROR]\t#{__METHOD_NAME__}: lock target '#{target}' does not exists" \
        if (! target.exists)

      const lock_file = self._glue_absolute(target)

      if (lock_file.exists) {
        self._lock_exists(target, cleanup)
      } else {
        MultiFactor::atomic_write(lock_file, self.UUID)
        self.vbs(__LINE__, __METHOD_NAME__, "created #{_bn(lock_file)}")
      }
    }

    method do_lock_files {
      self.config_setup
      self._do_remove_old_lock
      self.trc(__LINE__, __METHOD_NAME__, "locking FODs: #{self.locked_fods.map{ _bn(_) }.join(', ')}")
      self.locked_fods.each{
          |target|
        self._do_lock_file( target, false )
      }
      self.vbs(__LINE__, __METHOD_NAME__, "done locking FODs!")
    }

    method cleanup_lock_files {
      self.config_setup
      self.trc(__LINE__, __METHOD_NAME__, "cleanup lock files for FODs: #{self.locked_fods.map{ _bn(_) }.join(', ')}")
      self.locked_fods.each{
          |target|
        self._do_lock_file( target, true )
      }
      self.vbs(__LINE__, __METHOD_NAME__, "cleaned up lock files!")
    }

    -> _blob_file_contents_sum (File f, Str algo) {
      self.vbs(__LINE__, __METHOD_NAME__, "checksumming #{f} with algorithm '#{algo}'")
      self.fbash.with_directory{ BuildSh::blob_file_contents_sum(f, algo || self.sum_blob_algo) }
    }

    -> current_status_to_builtobj (Hash status) -> BuiltObj {
      self.vbs(__LINE__, __METHOD_NAME__, 'creating BuiltObj from scratch')
      var bo = BuiltObj().id(self.UUID)
      status.keys.each{
          |prop|
        # self.vbs(__LINE__, __METHOD_NAME__, "invoke method / property '#{prop}'")
        bo.method(prop)( status{prop} )
      }
      self.vbs(__LINE__, __METHOD_NAME__, 'setting creation time')
      bo.time_created(Time.now)
    }

    -> compile_vm_lib (BuiltObj bo) -> Bool {
      if ( ! self.fbash.build_factor(bo) ) {
        self.cleanup_lock_files
        die "vm compilation failed!"
      }
      self.vbs(__LINE__, __METHOD_NAME__, "vm compiled")
      true
    }
    -> compile_vm (o)  { self.compile_vm_lib(o) }
    -> compile_lib (o) { self.compile_vm_lib(o) }

    -> compile_image (BuiltObj bo) -> Bool {
      if (! self.fbash.build_image(bo) ) {
        self.cleanup_lock_files
        die "image compilation failed!"
      }
      self.vbs(__LINE__, __METHOD_NAME__, "image compiled")
      true
    }

    # NOTE: modifies obj
    -> sum_save_boot_image (BuiltObj obj) {
      self.fbash.with_directory{
        const disk_sum = self._blob_file_contents_sum(obj.boot_fullname, obj.blob_algorithm)
        if ( disk_sum != obj.blob_sums.boot ) {
          obj.blob_sums( BlobSums(
            algo: obj.blob_algorithm || self.sum_blob_algo,
            boot: disk_sum,
            # set the rest of the properties to their old values
            [:vm, :image, :lib].map{
                |n|
              n ¦ bo_target.blob_sums.method(n)
            }...
          ))
          bo_target.stored_boot_image(Hash(
            :sum => disk_sum,
            :data => obj.boot_fullname.slurp.encode_utf8,
            :algo => obj.stored_boot_image.algo || obj.blob_algorithm || self.sum_blob_algo
          ))
        }
      }
    }

    -> _make_disk_blob_sums (BuiltObj bo, Array targets) {
      BlobSums(
        algo: self.sum_blob_algo,
        targets.map{
            |target|
          ( target ¦ self._blob_file_contents_sum( bo.method(target + :_fullname)(), bo.blob_algorithm ) )
        }...
      )
    }

    -> build_new_factor (Hash current_status) {
      const MN = __METHOD_NAME__
      self.trc(__LINE__, MN, 'no match in db!')
      # interpret the current_status keys as property (setter) names in BuiltObj
      # this call does not set all properties, only those listed in status_properties
      return self.current_status_to_builtobj(current_status).cleave(
        { |n| self.compile_vm_lib(n) },
        { |n| self.compile_image(n)  },
        { |n| n.blob_sums( self._make_disk_blob_sums(n, [:vm, :image, :lib, :boot]) ) },
        { .lock },
        { self.trc(__LINE__, MN, 'writing the new BuiltObj to disk db because it changed') },
        { self.db_insert(_) }
        { self.trc(__LINE__, MN, "ok, running factor!") }
        { self.cleanup_lock_files }
        { self._detach_factor_thread(_.vm_fullname) }
      )
    }

    # multifactor's actual entry point
    # TODO: make this asynchronous, so that with_directory stuff is
    # done in a separate actor and awaited

    # DONE: dynamic hash algo selection
    # TODO: read mtimes
    # TODO: test whether the images are older than the file mtimes?!
    # TODO: write mtime/atimes
    # TODO: testability
    # DONE: if branches
    # DONE: make use of git information
    # DONE: compare OS, ARCH, WORD SIZE information
    # TODO: image compression?
    method go (Bool is_restart = false) {
      const MN = __METHOD_NAME__
      self.config_setup
      if (self.info) { self.show_info; return nil }

      self.do_lock_files

      given (self.action) {
        when ('src-sums') {
          self.fbash.say_src_sums
          return self.cleanup_lock_files
        }
        when ('env-info') {
          self.fbash.say_env_info
          return self.cleanup_lock_files
        }
      }

      # property names in BuiltObj, used to create current_status
      # BuildSh and FactorBash implement these through FactorBash.delegate
      const status_properties = [
        :factor_version, :is_git, :git_branch, :git_hash,
        :os_type, :os_name, :arch_name, :word_size,
        # fix this up?
        [ :vm_format,    default: { [ '', :fvm_, BuildSh::platform_vm_ext() ] } ],
        [ :image_format, default: { [ '', :fvm_, '.image' ] } ],
        [ :lib_format,   default: { [ BuildSh::platform_lib_name()..., :fvm_].swap(-2, -1) } ],
        [ :boot_format,  default: { [ 'boot.', :fvm_, '.image' ] } ]
        # the block is called for its default value but without arguments,
        #   because a "normal" version of the :sum_algorithm method in FactorBash
        #   requires knowledge of its containing class
        # this allows setting the blob checksum algorithm from the command line arguments
        [ :blob_algorithm, default: { self.sum_blob_algo } ],
        # this allows setting the SrcSums checksum algorithm for the VM on the command line
        [ :src_sums, args: [self.sum_src_algo, self.basis_dev] ],
      ]
      subset ArrStr < String, Array
      # makes Array<String, default?, args?> into String
      -> undefault_single (prop < ArrStr) -> String { [@|prop] -> first }
      # makes Array<Array<String, default?, args?>> into Array<String>
      -> undefault (Array props) -> Array { props.map{ undefault_single(_) } }

      # current_status is a Hash representing current disk / system config
      # it maps string property names in status_properties to the result of
      #   determining their values through FactorBash.delegate
      # '@|' is like '...' but only calls '...' when the object can recieve it
      const current_status = status_properties.map{ |n| (undefault_single(n), self.fbash.delegate(@|n)) }.to_h
      const db_data = self.load_db
      if (self.debug) {
        say current_status
        say db_data
      }

      # compare_properties just wants the Array<String> as its basis for
      #   comparing properties
      # we're done with the status_properties Array<String, default?, args?>
      #  now but it may come in handy
      const match_bo = db_data.values.find{
        |b|
        # remember, we're not testing *all* properties like .lock or tombstoned
        MultiFactor::compare_properties(undefault(status_properties), b, current_status, debug: self.debug)
      }

      # need to generate new ID and compile
      if (! match_bo) { return self.build_new_factor(current_status) }

      # now this is definitely defined
      match_bo.lock

      if (match_bo.time_tombstoned != 'never') {
        say '!!! matching entry is tombstoned!'
        # need to trash the old entry
        ...
        return self.build_new_factor(current_status)
      }

      self.vbs(__LINE__, MN, 'matching object in db')

      define tracked_targets = [:vm, :lib, :image]

      -> do_recompile_needed (BlobSums cur_blob_sums = nil) -> Hash {
        tracked_targets.map{
            |target|
          (target) => if (
            match_bo.cleave( # just to re-bind
              {
                  |b|
                self.fbash.with_directory{
                  const exists = b.method(target + :_fullname).exists
                  const disk_sum = self._blob_file_contents_sum( b.method(target + :_fullname)(), b.blob_algorithm )
                  const matched_sum = b.blob_sums.method(target)()
                  const sum_indirect = (defined(cur_blob_sums)
                    ? ( b.blob_sums.method(target)() =~ cur_blob_sums.method(target)() )
                    : false)
                  (exists == false) || ((disk_sum != matched_sum) && (sum_indirect == false))
                }
              }
            ).last
          ) {
            self.trc(__LINE__, MN, "#{target} named '#{match_bo.method(target + :_fullname)()}' not exists / matches checksum: rebuilding")
            ...
            self.method(:compile_ + target)(match_bo)
          } else { self.vbs(__LINE__, MN, "#{target} named '#{match_bo.method(target + :_fullname)()}' EXIST+MATCH: not rebuilding") }
        }.to_h
      }

      var (
        new_recompiled = do_recompile_needed(),
        current_blob_sums = self._make_disk_blob_sums(match_bo, tracked_targets)
      )

      new_recompiled = do_recompile_needed(cur_blob_sums: current_blob_sums)
      current_blob_sums = self._make_disk_blob_sums(match_bo, tracked_targets)

      self.vbs(__LINE__, MN, "done calculating checksums and rebuilding")

      # if they STILL don't match, delete the files + tombstone the entry and quit
      if ( ! (current_blob_sums =~ match_bo.blob_sums) ) {
        self.trc(__LINE__, MN, 'blob sums still mismatched!')
        if (is_restart) {
          self.trc(__LINE__, MN, "i give up (already in a restart)")
          return self.cleanup_lock_files
        }
        self.trc(__LINE__, MN, "starting over...")
        const tombstoning = (match_bo |> :dclone |> :unlock)
        del match_bo
        tombstoning.time_tombstoned(Time.now)

        self.db_insert(tombstoning)
        self.capture_write_disk(MN, { tracked_targets.each{ tombstoning.method(_ + :_fullname)().remove } } )
        return self.go(is_restart: true)
      }

      # OK, going to update the DB and run Factor

      # only updating the blob sums IFF the blob was newly compiled
      # otherwise, just update the mod/access times and run count
      const new_match_bo = match_bo.cleave( { .lock }, { .dclone } ).last
      if ( [ new_recompiled{ tracked_targets... } ].any{ _ } ) {
        self.vbs(__LINE__, MN, 'writing memory BuiltObj because of the newly compiled VM')
        new_match_bo.blob_sums(current_blob_sums)
        new_match_bo.time_modified(Time.now)
      }

      new_match_bo.lock

      # ?????
      const changed_db = if (match_bo != new_match_bo) {
        self.trc(__LINE__, MN, 'writing the new BuiltObj to disk db because it changed')
        self.db_insert(new_match_bo)
        true
      }

      # say "Eventual successful configuration!"
      # say "\tmatching_vm_name:\t'#{matching_vm_name}' # #{disk_vm_sum[0..10]}...\tmatching_image_name:\t'#{matching_image_name}' #{disk_image_sum[0..10]}..."
      # say "\tvm_sums_match:\t\t#{vm_blob_sums_match}/#{new_vm_blob_sums_match}"
      # say "\timage_sums_match:\t#{image_blob_sums_match}/#{new_image_blob_sums_match}"
      # say "\tchanged_db:\t\t#{changed_db}\t\t\tnewly_compiled: #{newly_compiled.to_s.chars.grep{|p|![\"\n\",' '].any{p==_} }.join}"
      self.trc(__LINE__, MN, "ok, running factor!")
      self.cleanup_lock_files
      self._detach_factor_thread(match_bo.vm_fullname)
    }

    -> _detach_factor_thread (String vm_name) {
      const MN = __METHOD_NAME__
      {
        self.inf(__LINE__, MN, 'Launching Factor: ', "'", vm_name, self.factor_arguments..., "'")
        if (! self.fbash.with_directory{
          Command::spawn_se('./' + vm_name, self.factor_arguments..., output: true)
        } ) {
          self.inf(__LINE__, MN, "Failed: #{$!}")
        }
      }.thr.detach
      # don't segfault
    }
  }
}

define MICRO_MAGNITUDE = 1_000
func μsec { Time.micro*MICRO_MAGNITUDE }
func μsec (Number n) { Time.micro*MICRO_MAGNITUDE - n }

func main {
  const μs = μsec()
  μs
  # say Factor::RC_FILE
  # say Factor::REPO
  # say Factor::VERSION
  # say Dir.cwd
  # say Dir.cwd
  # Dir.chdir(Factor::REPO)
  # say BuildSh::generate_make_targets()
  # say FactorBash::sum_git_names_matching(/\.s(?:m|f)/)
  # say FactorBash::sum_git_contents_matching(/\.s(?:m|f)/)
  # say MultiFactor::BuiltObj(([""] * 15)..., false ).dump.len

  const parser = argparse::ArgParse(ARGV) \
    .info(SCRIPT) \
    .option("force", :f, doc: "Force a rebuild in any case") \
    .option("trace", :t, doc: "Some debug tracing") \
    .option("verbose", :V, doc: "Verbose debug tracing") \
    .option("info", :i, doc: "Just show configuration information") \
    .option("dry-run", :n, doc: "Change no disk files") \
    .option("clean", :c, negate: "Always":"Never", doc: "'make clean'") \
    .option("sums", :s,  negate: "Always":"Never", doc: "use checksums") \

    .option("db-name", :D, param: "name":".multifactor.db", doc: "Custom database filename") \
    .option("db-path", :d, param: "path":".", doc: "Path to dir containing database") \
    .option("factor-dir", :w, param: "path":".", doc: "Path to Factor working directory") \
    .option("remove-old-lock", :R, doc: "Blindly remove any lock files (unsafe!)") \
    .option("quiet-subcom", :q, negate: "Never":"Always", doc: "show subcommand outputs") \
    # TODO: argparse can accept a list of allowed values
    .option(
      "action", "a", param: "name":"run-factor",
      doc: "Perform this action\nactions: run-factor, src-sums, env-info"
    ) \
    .option("basis-dev", :b, doc: "Ignore changes in basis/\n(basis development mode)") \
    .use_option_terminator("Further arguments are given to Factor") \
    # .use_stdin_file_arg \
    # .use_arg_list_terminator \
    # .ignore_unknowns \
    # .help_on_stderr \
    .arg("arg...", doc: "Arguments to the final Factor VM")

  var (opts, args, *_) = parser.go...
  # say "#{opts} #{args} #{_}"

  const r = MultiFactor::Runtime(opts, args.keys)

  # r.show_info()
  r.go()

  Factor::say_stderr("\n\tΔ#{μsec(μs)} ×1,000μ")
}

if (__FILE__ == __MAIN__) {
  main()
}
