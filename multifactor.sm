#! sidef -WkP8
# /usr/bin/env
#`(exit the shell) {
  eval 'exec sidef -WkP8 $0 ${1+"$@"}'
}

##  MultiFactor, meta build system for Factor core development
##    Copyright Cat Stevens 2018
##  This program is free software: you can redistribute it and/or modify
##    it under the terms of the GNU General Public License as published by
##    the Free Software Foundation, either version 3 of the License, or
##    (at your option) any later version.
##
##    This program is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
##
##    You should have received a copy of the GNU General Public License
##    along with this program.  If not, see <https://www.gnu.org/licenses/>.

include argparse
include shell_words

define Hash SCRIPT = :(
  "version" => "0.3",
  "name" => "multifactor",
  "doc" => "a meta build system for Factor core development",
  "bug" => "github.com/catb0t/multifactor/issues",
  "license" => "GPL v3+"
)

# basic variable definitions for working with Factor
module Factor {
  const String RC_FILE = Dir.home+%f(.factor-rc)

  func find_config (name) {
    const regex = Regex("^! multifactor:#{name} (.*)")
    File(RC_FILE).open_r.lines.each {
      with ( .match(regex)[0] ) { return _ }
    }
    die "Config 'multifactor:#{name}' not found in #{Factor::RC_FILE}"
  }

  const Dir REPO = Dir(find_config("repo"))
  const Regex VERSION_REGEX = /VERSION = ([0-9]+\.[0-9]+)/
  const String VERSION = (
    VERSION_REGEX =~ (
      REPO + %f(GNUmakefile)->open_r.lines.find { |l| l ~~ VERSION_REGEX }
    )
  )[0]
}

module MultiFactor {
  # accessors are a necessity
  class BuiltObj (
    String _id,                     # long uuid
    String _git_branch,             # branch to which this applies
    String _git_hash,               # hash it's from; git rev-parse HEAD
    String _os_type,                # target os kind
    String _os_name,                # specific os string
    String _arch_name,              # x86 / ppc / arm ...
    String _word_size,              # 32 / 64
    String _sum_vm_names,           # a sha256 checksum
    String _sum_vm_contents,        # .
    String _sum_image_names,        # .
    String _sum_image_contents,     # .
    String _vm_blob_sum,            # .
    String _image_blob_sum,         # .
    String _time_created,           # epoch timestamp
    String _time_mod_access,        # 2 timestamps in the form "xxx/yyy"
    String _time_tombstoned = :never, # for once-existing now-deleted images; stores deletion time
    String _vm_base_name = :factor, # usually "factor"
    String _image_ext = ".image",   # usually ".image"
    Bool   _lk = false              # object locking
  ) {
    -> lock () -> BuiltObj { self._lk = true; self }
    # -> unlock () -> BuiltObj { self._lk = false; self }
    -> id () -> String { self.id }
    -> git_branch () -> String { self._git_branch }
    -> git_hash () -> String { self._git_hash }
    -> os_type () -> String { self._os_type }
    -> os_name () -> String { self._os_name }
    -> arch_name () -> String { self._arch_name }
    -> word_size () -> String { self._arch_name }
    -> sum_vm_names () -> String { self._sum_vm_names }
    -> sum_vm_contents () -> String { self._sum_vm_contents }
    -> sum_image_names () -> String { self._sum_image_names }
    -> sum_image_contents () -> String { self._sum_image_contents }
    -> vm_blob_sum () -> String { self._vm_blob_sum }
    -> image_blob_sum () -> String { self._image_blob_sum }
    -> vm_base_name () -> String { self._vm_base_name }
    -> image_ext () -> String { self._image_ext }
    -> time_created () -> String { self._time_created }
    -> time_mod_access () -> String { self._time_mod_access }
    -> time_tombstoned () -> String { self._time_tombstoned }

    -> id (String id) -> BuiltObj { if (!self._lk) { self._id = id }; self }
    -> git_branch (String gb) -> BuiltObj { if (!self._lk) { self._git_branch = gb }; self }
    -> git_hash (String hs) -> BuiltObj { if (!self._lk) { self._git_hash = hs }; self }
    -> os_type (String os) -> BuiltObj { if (!self._lk) { self._os_type = os }; self }
    -> os_name (String os) -> BuiltObj { if (!self._lk) { self._os_name = os }; self }
    -> arch_name (String an) -> BuiltObj { if (!self._lk) { self._arch_name = an }; self }
    -> word_size (String ws) -> BuiltObj { if (!self._lk) { self._word_size = ws }; self }
    -> sum_vm_names (String x) -> BuiltObj { if (!self._lk) { self._sum_vm_names = x }; self }
    -> sum_vm_contents (String x) -> BuiltObj { if (!self._lk) { self._sum_vm_contents = x }; self }
    -> sum_image_names (String x) -> BuiltObj { if (!self._lk) { self._sum_image_names = x }; self }
    -> sum_image_contents (String x) -> BuiltObj { if (!self._lk) { self._sum_image_contents = x }; self }
    -> vm_blob_sum (String x) -> BuiltObj { if (!self._lk) { self._vm_blob_sum = x }; self }
    -> image_blob_sum (String x) -> BuiltObj { if (!self._lk) { self._image_blob_sum = x }; self }
    -> vm_base_name (String x) -> BuiltObj { if (!self._lk) { self._vm_base_name = x }; self }
    -> image_ext (String x) -> BuiltObj { if (!self._lk) { self._image_ext = x }; self }
    -> time_created (String x) -> BuiltObj { if (!self._lk) { self._time_created = x }; self }
    -> time_mod_access (String x) -> BuiltObj { if (!self._lk) { self._time_mod_access = x }; self }
    -> time_tombstoned (String x) -> BuiltObj { if (!self._lk) { self._time_tombstoned = x }; self }
  }

  include Factor
  include FactorBashStateless

  define String temp_read_ext = "\.tmp_read"
  define String temp_write_ext = "\.tmp_write"

  -> temp_read_target (File name) is cached -> File {
    File(name + MultiFactor::temp_read_ext + FactorBashStateless::make_uuid() )
  }
  -> temp_write_target (File name) is cached -> File {
    File(name + MultiFactor::temp_write_ext + FactorBashStateless::make_uuid() )
  }

  # NOTE: NOT instance-specific, i.e doesn't use *OUR* UUID in name
  # this copies a file to a temporary for reading
  func temp_r (File name) -> File {
    die "Cannot stat #{name}" if (! name.exists)
    const File target = MultiFactor::temp_read_target(name)
    if (! name.copy(target) ) {
      die "Copy file #{name} to #{target}: failed, $!"
    }
    target
  }
  # this makes a temp file for writing, which can be rename()d over `name`
  func temp_w (File name) -> File {
    const File target = MultiFactor::temp_write_target(name)
    if (target.exists) {
      die "Create file #{target}: file exists"
    }
    target
  }
  # argument is used literally
  func finalise_temp_r (File target) {
    die "Cannot stat #{target}" if (! target.exists)
    if (! target.remove) {
      die "Can't remove #{target}: $!"
    }
  }
  # requires literal arguments due to UUID
  func finalise_temp_w (File name, File target) {
    die "Cannot stat #{target}" if (! target.exists)
    if (! target.mv(name)) {
      die "Can't move #{target} over #{name}: $!"
    }
  }

  # these are actually the interfaces to the above words
  # this returns a filehandle to in-memory string
  func atomic_read (File name) -> String {
    const File tmp = MultiFactor::temp_r(name)
    const tmp_fh = tmp.open_r
    const String contents = tmp_fh.slurp.dclone()
    contents # won't be eagerly evaluated without this line
    # check error here?
    tmp_fh.close
    MultiFactor::finalise_temp_r(tmp)
    contents
  }
  func atomic_write (File name, String contents) {
    const File tmp = MultiFactor::temp_w(name)
    const tmp_fh = tmp.open_w
    const Bool res = tmp_fh.spurt(contents)
    if (! res) {
      die "Couldn't write #{contents.len} to #{tmp}: $!"
    }
    tmp_fh.close
    MultiFactor::finalise_temp_w(name, tmp)
    return nil
  }

  func _read_disk_db (File name) is cached -> Array {
    # look for the database file
    # if it doesn't exist, stop
    # otherwise, open it
    const contents = MultiFactor::atomic_read(name)
    # if it's empty, get a new one -> []
    if (! contents) {
      return []
    }
    const eval_contents = eval(contents)
    # if it's not empty, but contains invalid / throwing code, THAT's an error!
    if (! defined(eval_contents)) {
      die "Malformed db: #{name} (it failed to eval): #{contents}"
    }
    # if it contains only [], it's also empty -> []
    if (! eval_contents) {
      return []
    }
    # if it contains [BuiltObj()...], it's nonempty -> [BuiltObj()...]
    eval_contents.all{_ ~~ BuiltObj} || die "Found garbage in #{name}: #{contents}"
    return eval_contents
  }

  func _write_disk_db (File name, Array new_data) {
    const String new_contents = new_data.dump # safe ???
    # look for the database file
    # if it doesn't exist, stop
    # otherwise, open it
    MultiFactor::atomic_write(name, new_contents)
  }

  class Runtime (
    Hash options,
    Array factor_arguments
  ) {
    has Bool _config_setup_done = false # whether the following variables have been written
    has Str lock_ext = ".multifactor_lock"
    has Str lock_name

    has Bool force
    has Bool trace
    has Bool verbose
    has Bool info
    has Bool dry_run
    has Bool clean
    has Bool sums

    # set in config file
    has Number sum_len

    has Dir db_path
    has File db_name
    has File db

    has Dir factor_path
    has FactorBash fbash

    has String _UUID
    -> UUID () -> String { self._UUID }
    -> UUID (String u) -> MultiFactor::Runtime { self._UUID = u; self }

    -> trc (fun, *args) { say "[TRACE]\t#{fun}: #{args.join(' ')}" if (self.trace) }
    # more verbose than trace
    -> vbs (fun, *args) { say "[VBOSE]\t#{fun}: #{args.join(' ')}" if (self.verbose) }

    method config_setup {
      if (! self._config_setup_done) {
        self.db_name = File(self.options(){'db-name'})
        self.db_path = Dir(self.options(){'db-path'})
        self.db = self.db_path+self.db_name

        self.factor_path = Dir(self.options(){'factor-path'})
        self.fbash = shell_words::FactorBash(self.factor_path)
        self.UUID(FactorBashStateless::make_uuid())

        self.force = Bool(self.options\{:force})
        self.dry_run = Bool(self.options(){'dry-run'})
        self.trace = Bool(self.options\{:trace} || self.dry_run)
        self.verbose = ( Bool(self.options\{:verbose}) || self.trace || self.dry_run )
        self.info = Bool(self.options\{:info})

        # TODO: argparse needs to
        # correctly fill out non-provided negatable booleans
        self.clean = Bool(self.options\{:clean})
        self.sums = Bool(self.options\{:sums})

        self.lock_name = File(self.db+self.lock_ext)

        self._config_setup_done = true
        self.vbs(__METHOD_NAME__, "finished configuration, moved to #{self.db_path}")
      }
    }

    method show_info {
      self.config_setup
      say "MultiFactor #{self.UUID} options"
      say "\tverbose: #{self.verbose}\tinfo: #{self.info}\ttrace: #{self.trace}\tdry_run: #{self.dry_run}"
      say "\tclean: #{self.clean}\tsums: #{self.sums}\tdb_name: #{self.db_name}\tdb_path: #{self.db_path}"
      say "\tfactor_path: #{self.factor_path}\tdb: #{self.db}"
      say "\tFactor arguments: #{self.factor_arguments}"
    }

    method capture_write_disk (Block operation, String caller_name) {
      if (! self.dry_run) {
        self.vbs(__METHOD_NAME__, "#{caller_name}: writing disk with #{operation}")
        return operation.run
      }
      self.vbs(__METHOD_NAME__, "#{caller_name}: not writing disk (dry run)")
      nil
    }

    method read_disk_db () is cached -> Array {
      self.config_setup
      self.trc(__METHOD_NAME__, "reading #{self.db}")

      MultiFactor::_read_disk_db(self.db)
    }

    method write_disk_db (Array new_data) {
      self.config_setup
      self.trc(__METHOD_NAME__, "writing #{self.db}")

      if ( defined(new_data) && Bool(new_data) && new_data.all{_ ~~ BuiltObj} ) {
        self.capture_write_disk( { MultiFactor::_write_disk_db(self.db, new_data) }, __METHOD_NAME__ )
      } else {
        self.cleanup_lock_file
        die "[ERROR]\t#{__METHOD_NAME__}: garbage argument #{new_data}"
      }
    }

    -> _test_lock_file (Bool cleanup) {
      const String first_line = self.lock_name.open_r.readline
      # err on the side of caution
      die "[ERROR]\t#{__METHOD_NAME__}: malformed lockfile #{self.lock_name} exists and is empty\n\t(not removing; not continuing)" \
        if (! defined(first_line) || !first_line)
      if ( first_line.chomp != self.UUID() ) {
        # otherwise, if the file is empty or lacks a UUID, it's not ours
        # we should die
        self.vbs(__METHOD_NAME__, "UUID mismatch: #{first_line.chomp.dump} ≠ #{self.UUID.dump}")
        die (
          "[ERROR]\t#{__METHOD_NAME__}: lockfile #{self.lock_name} contains foreign UUID" +
          "\n\t(only one MultiFactor process should be active in a directory)"
          "\n\tnot removing it; not continuing"
        )
        # Sys.exit(136)
      } else {
        if (cleanup) { self.lock_name.remove }
        else {
          warn (
            "[WARN]\t#{__METHOD_NAME__}: my UUID already exists in the lockfile #{self.lock_name}" +
            "\n\tUnnecessary read; MultiFactor bug found! in #{Dir.cwd}"
          )
        }
      }
    }

    # NOTE: this ensures "we are a running process and we must be the only such running process"
    # different from the tmp_file implementation above
    # database "locking" should consist primarily in rename()
    # NOTE: NIH: want to avoid CPAN deps
    method do_lock_file {
      self.config_setup

      die "[ERROR]\t#{__METHOD_NAME__}: empty dbname! lock_name was #{self.lock_name}" \
        if (self.lock_name.to_s == lock_ext)
      # if it doesn't exist, create it with our UUID
      if (! self.lock_name.exists) {
        const File fh = lock_name.create
        die "[ERROR]\t#{__METHOD_NAME__}: failed to create lockfile #{self.lock_name}: $!" \
          if (! defined(fh))
        fh.spurt(self.UUID)
        fh.close
        self.vbs(__METHOD_NAME__, "created #{self.lock_name}")
      } else {
        # otherwise, and if the contained UUID is ours, it must be ours (right?)
        # do nothing, but warn
        self._test_lock_file(false)
      }
    }

    method cleanup_lock_file {
      self.config_setup
      if (! self.lock_name.exists) {
        warn "[WARN]\t#{__METHOD_NAME__}: Cannot stat #{self.lock_name}"
      } else {
        self.vbs(__METHOD_NAME__, "removing #{self.lock_name}")
        self._test_lock_file(true)
      }
    }

    # multifactor's actual entry point
    method go {
      self.config_setup
      if (self.info) { self.show_info; return nil }

      self.do_lock_file

      const (
        vm_sums = self.fbash.sum_vm_source,
        image_sums = self.fbash.sum_image_source
      )
      say "vm: #{vm_sums}"
      say "image: #{image_sums}"

      const db_data = self.read_disk_db
      const builtobj_matching_source = db_data.find{
          |b|
        b.sum_vm_contents==vm_sums{:contents} && b.sum_vm_names==vm_sums{:names} \
        && b.sum_image_contents==image_sums{:contents} && b.sum_image_names==image_sums{:names} \
      }
      if (! defined(builtobj_matching_source)) {
        say "no file"
        self.cleanup_lock_file
        return nil
      }

      say db_data
      say builtobj_matching_source
      const want_blobs_named = builtobj_matching_source.id
      const (
        want_vm = File(want_blobs_named),
        want_image = File("#{want_blobs_named}.image")
      )

      const (want_vm_sum, want_image_sum = self.fbash.with_directory{
        want_vm.exists && want_vm.open_r.slurp.bytes.sha256, want_image.exists && want_image.open_r.slurp.bytes.sha256
      })
      # db.map { .word_size("64") }
      #say db.dump
      # no changes to disk yet, also haven't read from git yet
      # self.write_disk_db(db)

      self.cleanup_lock_file
    }
  }
}

define MICRO_MAGNITUDE = 1_000
func μsec { Time.micro*MICRO_MAGNITUDE }
func μsec (Number n) { Time.micro*MICRO_MAGNITUDE - n }

func main () {
  var μs = μsec()
  # say Factor::RC_FILE
  # say Factor::REPO
  # say Factor::VERSION
  # say Dir.cwd
  # say Dir.cwd
  # Dir.chdir(Factor::REPO)
  # say BuildSh::generate_make_targets()
  # say FactorBash::sum_git_names_matching(/\.s(?:m|f)/)
  # say FactorBash::sum_git_contents_matching(/\.s(?:m|f)/)
  # say MultiFactor::BuiltObj(([""] * 15)..., false ).dump.len

  var parser = argparse::ArgParse(ARGV) \
    .info(SCRIPT) \
    .option("force", "f", doc: "Force a rebuild in any case") \
    .option("trace", "t", doc: "An unreasonable amount of debug tracing") \
    .option("verbose", "V", doc: "Be verbose") \
    .option("info", "i", doc: "Just show configuration information") \
    .option("dry-run", "n", doc: "Change no disk files") \
    .option("clean", "c", negate: "Always":"Never", doc: "'make clean'") \
    .option("sums", "s",  negate: "Always":"Never", doc: "use checksums") \
    # probably don't need this, or set it in config file
    # .option("sum-len", "l", param: "len":"12", doc: "Shorten checksums to this length") \
    .option("db-name", "D", param: "name":".multifactor.db", doc: "Custom database filename") \
    .option("db-path", "d", param: "path":".", doc: "Path to dir containing database") \
    .option("factor-path", "w", param: "path":".", doc: "Path to Factor working directory") \
    .use_option_terminator("Further arguments are given to Factor") \
    # .use_stdin_file_arg \
    # .use_arg_list_terminator \
    # .ignore_unknowns \
    # .help_on_stderr \
    .arg("arg...", doc: "Arguments to the final Factor VM")

  var (opts, args, *_) = parser.go...
  say "#{opts} #{args}"

  const r = MultiFactor::Runtime(opts, args.keys)

  r.show_info()
  r.go()


  say "\n\tΔ#{μsec(μs)} ×1,000μ"
}

if (__FILE__ == __MAIN__) {
  main()
}
