#! sidef -vWkP8
# /usr/bin/env
#`(exit the shell) {
  eval 'exec sidef -WkP8 $0 ${1+"$@"}'
}

##  MultiFactor, meta build system for Factor core development
##    Copyright Cat Stevens 2018
##  This program is free software: you can redistribute it and/or modify
##    it under the terms of the GNU General Public License as published by
##    the Free Software Foundation, either version 3 of the License, or
##    (at your option) any later version.
##
##    This program is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
##
##    You should have received a copy of the GNU General Public License
##    along with this program.  If not, see <https://www.gnu.org/licenses/>.
class Object {
  method cleave (*blocks) {
    blocks.map{ .run(self) } # ...
  }
  method ifold (*bv_pairs) {
    bv_pairs.map{ |p| p.first.run( self, @(p.second)... ) }...
  }
}

include argparse
include shell_words

define Hash SCRIPT = :(
  "version" => "0.3",
  "name" => "multifactor",
  "doc" => "a meta build system for Factor core development",
  "bug" => "github.com/catb0t/multifactor/issues",
  "license" => "GPL v3+"
)

# basic variable definitions for working with Factor from a high-level perspective
module Factor {
  const File RC_FILE = Dir.home+%f(.factor-rc)

  func rc_config_lines () is cached -> Array {
    Factor::RC_FILE.open_r.lines.grep{ _ ~~ /^! multifactor:/ }
  }

  func find_config (name) is cached -> String {
    const regex = Regex("^! multifactor:#{name} (.*)")
    const result = Factor::rc_config_lines().find{ _ ~~ regex } \
      || die "Config 'multifactor:#{name}' not found in #{Factor::RC_FILE}"
    (regex =~ result)[0]
  }

  const Dir FOLDER = Dir(Factor::find_config("factor-dir"))
  const Bool QUIET_PIPE = Bool(Factor::find_config("quiet-pipe"))

  # ???
  func say_stderr (*args) {
    if (STDOUT.is_on_tty || (!STDOUT.is_on_tty && !Factor::QUIET_PIPE)) {
      STDERR.autoflush(true)
      STDERR.say(args...)
    }
    # else, not a TTY and quiet-pipe is true
  }
}

module MultiFactor {
  import shell_words::SrcSums

  # accessors are a necessity
  class BuiltObj (
    Str  _id = '',                  # long uuid
    Str  _factor_version = '',      # 0.98, 0.99
    Str  _git_branch = '',          # branch to which this applies
    Str  _git_hash = '',            # hash it's from; git rev-parse HEAD
    Str  _os_type = '',             # target os kind
    Str  _os_name = '',             # specific os string
    Str  _arch_name = '',           # x86 / ppc / arm ...
    Str  _word_size = '',           # 32 / 64
    SrcSums _vm_sums = SrcSums(),   #
    SrcSums _image_sums = SrcSums(),# .
    Str  _vm_blob_sum = '',         # .
    Str  _image_blob_sum = '',      # .
    Num  _time_created = 0,         # epoch timestamp
    Num  _time_modified = 0,       # .
    Num  _time_accessed = 0,         # .
    Bool _is_git = true,            # whether it's in a git repository
    Str _time_tombstoned = :never, # for once-existing now-deleted images; stores deletion time
    Str  _vm_ext = '',              # usually "factor"
    Str  _vm_prefix = :fvm_,        # usually "factor"
    Str  _image_ext = '.image',     # usually ".image"
    Str  _image_prefix = :fvm_,     # usually ".image"
    Str  _sum_algorithm = :sha256,  # usually sha256
    Bool _lk = false,               # object locking
    Str  _fail = 'attempted writing to locked BuiltObj object!'
  ) {
    -> lock () -> BuiltObj { self._lk = true; self }
    -> unlock () -> BuiltObj { self._lk = false; self }
    -> id () -> Str { self._id }
    -> factor_version () -> Str { self._factor_version }
    -> git_branch () -> Str { self._git_branch }
    -> git_hash () -> Str { self._git_hash }
    -> is_git () -> Bool { self._is_git }
    -> os_type () -> Str { self._os_type }
    -> os_name () -> Str { self._os_name }
    -> arch_name () -> Str { self._arch_name }
    -> word_size () -> Str { self._word_size }
    -> vm_sums () -> SrcSums { self._vm_sums }
    -> image_sums () -> SrcSums { self._image_sums }
    -> vm_blob_sum () -> Str { self._vm_blob_sum }
    -> image_blob_sum () -> Str { self._image_blob_sum }
    -> vm_ext () -> Str { self._vm_ext }
    -> vm_prefix () -> Str { self._vm_prefix }
    -> image_ext () -> Str { self._image_ext }
    -> image_prefix () -> Str { self._image_prefix }
    -> time_created () -> Num { self._time_created }
    -> time_modified () -> Str { self._time_modified }
    -> time_accessed () -> Str { self._time_access }
    -> time_tombstoned () -> Str { self._time_tombstoned }
    -> sum_algorithm () -> Str { self._sum_algorithm }

    -> id (Str id)             { die self._fail if (self._lk); self._id = id            ; self }
    -> factor_version (Str ve) { die self._fail if (self._lk); self._factor_version = ve; self }
    -> git_branch (Str gb)     { die self._fail if (self._lk); self._git_branch = gb    ; self }
    -> git_hash (Str hs)       { die self._fail if (self._lk); self._git_hash = hs      ; self }
    -> is_git (Bool g)         { die self._fail if (self._lk); self._is_git = g         ; self }
    -> os_type (Str os)        { die self._fail if (self._lk); self._os_type = os       ; self }
    -> os_name (Str os)        { die self._fail if (self._lk); self._os_name = os       ; self }
    -> arch_name (Str an)      { die self._fail if (self._lk); self._arch_name = an     ; self }
    -> word_size (Str ws)      { die self._fail if (self._lk); self._word_size = ws     ; self }
    -> vm_sums (SrcSums x)     { die self._fail if (self._lk); self._vm_sums = x        ; self }
    -> image_sums (SrcSums x)  { die self._fail if (self._lk); self._image_sums = x     ; self }
    -> vm_blob_sum (Str x)     { die self._fail if (self._lk); self._vm_blob_sum = x    ; self }
    -> image_blob_sum (Str x)  { die self._fail if (self._lk); self._image_blob_sum = x ; self }
    -> vm_ext (Str x)          { die self._fail if (self._lk); self._vm_ext = x         ; self }
    -> vm_prefix (Str x)       { die self._fail if (self._lk); self._vm_prefix = x      ; self }
    -> image_ext (Str x)       { die self._fail if (self._lk); self._image_ext = x      ; self }
    -> image_prefix (Str x)    { die self._fail if (self._lk); self._image_prefix = x   ; self }
    -> time_created (Num x)    { die self._fail if (self._lk); self._time_created = x   ; self }
    -> time_modified (Str x)   { die self._fail if (self._lk); self._time_modified = x  ; self }
    -> time_accessed (Str x)   { die self._fail if (self._lk); self._time_access = x    ; self }
    -> time_tombstoned (Str x) { die self._fail if (self._lk); self._time_tombstoned = x; self }
    -> sum_algorithm (Str x)   { die self._fail if (self._lk); self._sum_algorithm = x  ; self }

    -> vm_fullname () -> File { File( self.cleave( { .vm_prefix }, { .id }, { .vm_ext } ).join ) }
    -> image_fullname () -> File { File( self.cleave( { .image_prefix }, { .id }, { .image_ext } ).join ) }
  }

  include Factor
  include FactorBashStateless

  define String temp_read_ext = "\.tmp_read"
  define String temp_write_ext = "\.tmp_write"

  -> temp_read_target (File name) is cached -> File {
    File(name + MultiFactor::temp_read_ext + FactorBashStateless::make_uuid() )
  }
  -> temp_write_target (File name) is cached -> File {
    File(name + MultiFactor::temp_write_ext + FactorBashStateless::make_uuid() )
  }

  # NOTE: NOT instance-specific, i.e doesn't use *OUR* UUID in name
  # this copies a file to a temporary for reading
  func temp_r (File name) -> File {
    die "Cannot stat #{name}" if (! name.exists)
    const File target = MultiFactor::temp_read_target(name)
    if (! name.copy(target) ) {
      die "Can't copy file #{name} to #{target}: #{$!}"
    }
    target
  }
  # this makes a temp file for writing, which can be rename()d over `name`
  func temp_w (File name) -> File {
    const File target = MultiFactor::temp_write_target(name)
    if (target.exists) {
      die "Create file #{target}: file exists"
    }
    target
  }
  # argument is used literally
  func finalise_temp_r (File target) {
    die "Cannot stat #{target}" if (! target.exists)
    if (! target.remove) {
      die "Can't remove #{target}: #{$!}"
    }
  }
  # requires literal arguments due to UUID
  func finalise_temp_w (File name, File target) {
    die "Cannot stat #{target}" if (! target.exists)
    if (! target.move(name)) {
      die "Can't move #{target} over #{name}: #{$!}"
    }
  }

  # these are actually the interfaces to the above words
  # this returns a filehandle to in-memory string
  func atomic_read (File name) -> String {
    const File tmp = MultiFactor::temp_r(name)
    const tmp_fh = tmp.open_r
    die "Couldn't open file for reading: #{tmp}: #{$!}" if (! tmp_fh)
    const String contents = tmp_fh.slurp
    die "Read file '#{tmp}' failed: #{$!}" if (! defined(contents))
    contents # won't be eagerly evaluated (will be nil) without this line
    # check error here?
    tmp_fh.close
    MultiFactor::finalise_temp_r(tmp)
    contents
  }
  func atomic_write (File name, String contents) {
    const File tmp = MultiFactor::temp_w(name)
    const tmp_fh = tmp.open_w
    die "Couldn't open file for writing: #{tmp}: #{$!}" if (! tmp_fh)
    const Bool res = tmp_fh.spurt(contents)
    die "Couldn't write #{contents.len} bytes to #{tmp}: #{$!}" if (! res)
    tmp_fh.close
    MultiFactor::finalise_temp_w(name, tmp)
    return nil
  }

  func _read_disk_db (File name) is cached -> Hash {
    # look for the database file
    # if it doesn't exist, stop
    # otherwise, open it
    const contents = MultiFactor::atomic_read(name)
    # if it's empty, get a new one -> []
    if (! contents) {
      return Hash()
    }
    const eval_contents = eval(contents)
    # if it's not empty, but contains invalid / throwing code, THAT's an error!
    if (! defined(eval_contents)) {
      die "Malformed db: #{name} (it failed to eval): #{contents}"
    }
    # if it contains only [], it's also empty -> []
    if (! eval_contents) {
      return Hash()
    }
    # if it contains [BuiltObj()...], it's nonempty -> [BuiltObj()...]
    eval_contents.values.all{_ ~~ BuiltObj} || die "Found garbage in #{name}: #{contents}"
    return eval_contents
  }

  func _write_disk_db (File name, Hash new_data) {
    const String new_contents = new_data.dump # safe ???
    # look for the database file
    # if it doesn't exist, stop
    # otherwise, open it
    MultiFactor::atomic_write(name, new_contents)
  }

  func compare_properties (Array properties, BuiltObj b, Object o, Bool debug = false) {
    if (debug) {
      properties.map{
          |property|
        const db_property = b.method(property)()
        const status_property = o{property}
        say "Property '#{property}': #{db_property == status_property}: #{db_property.dump} == #{status_property.dump}"
        db_property == status_property
      }.all{ _ }
    } else {
      properties.map{ |prop| b.method(prop)() } ~Z== o{properties...} -> all{ _ }
    }
  }

  # subset Fs1Object < File, Dir

  class Runtime (Hash options, Array factor_arguments) {
    has Bool _config_setup_done = false # whether the following variables have been written
    has Str _lock_ext = ".multifactor_lock"
    has Str _action

    has Array db_changes # tracking order of reads/writes
    has Set locked_fods

    has Bool _force
    has Bool _trace
    has Bool _verbose
    has Bool _debug = false
    has Bool _info
    has Bool _dry_run
    has Bool _clean
    has Bool _sums
    has Bool _remove_old_lock

    has String _sum_blob_algo = :sha256
    has String _sum_src_algo = :sha256
    # set in config file etc, not a cmdline option
    # has Number uuid_len

    # where the process started before any chdir
    has Dir initial_wd

    has shell_words::FactorBash fbash

    has Dir  _factor_dir
    has Dir  _db_path
    has File _db_name

    has String _UUID

    -> UUID ()         { self._UUID }
    -> lock_ext        { self._lock_ext }
    -> action          { self._action }
    -> force           { self._force }
    -> trace           { self._trace }
    -> verbose         { self._verbose }
    -> debug           { self._debug }
    -> info            { self._info }
    -> dry_run         { self._dry_run }
    -> clean           { self._clean }
    -> sums            { self._sums }
    -> remove_old_lock { self._remove_old_lock }
    -> sum_src_algo    { self._sum_src_algo }
    -> sum_blob_algo   { self._sum_blob_algo }
    -> factor_dir      { self._factor_dir }
    -> db_path         { self._db_path }
    -> db_name         { self._db_name }
    -> db { self._db_path+self._db_name }

    -> UUID (Str u)             { self._UUID = u; self }
    -> lock_ext (Str e)         { self._lock_ext = e; self }
    -> action (Str a)           { self._action = a; self }
    -> force (Bool b)           { self._force = b; self }
    -> trace (Bool b)           { self._trace = b; self }
    -> verbose (Bool b)         { self._verbose = b; self }
    -> debug (Bool b)           { self._debug = b; self }
    -> info (Bool b)            { self._info = b; self }
    -> dry_run (Bool b)         { self._dry_run = b; self }
    -> clean (Bool b)           { self._clean = b; self }
    -> sums (Bool b)            { self._sums = b; self }
    -> remove_old_lock (Bool b) { self._remove_old_lock = b; self }
    -> sum_src_algo (Str a)     { self._sum_src_algo = a; self }
    -> sum_blob_algo (Str a)    { self._sum_blob_algo = a; self }
    -> factor_dir (Dir d)       { self._factor_dir = d; self }
    -> db_path (Dir d)          { self._db_path = d; self }
    -> db_name (File d)         { self._db_name = d; self }

    -> _bn { File(__FILE__).basename.split(".")[0] }
    -> _log (*a) { Factor::say_stderr(a...) }
    -> wrn (Num l, Str m, *args) { say "[WARN]\t#{l}: #{m}: #{args.join(' ')}" }
    -> inf (Num l, Str m, *args) { self._log("[INFO]\t", l, ': ', m, ': ', args.join(' ')) }
    -> trc (Num l, Str m, *args) { self._log("[TRACE]\t", l, ': ', m, ': ', args.join(' ')) if (self.trace) }
    -> vbs (Num l, Str m, *args) { self._log("[VBOSE]\t", l, ': ', m, ': ', args.join(' ')) if (self.verbose) }
    # more verbose than trace ^^^

    method config_setup {
      if (! self._config_setup_done) {
        self.UUID( FactorBashStateless::make_uuid() )
        self.initial_wd = Dir.cwd

        var props = Hash(
          :db_name => { File(_) },
          :db_path => { Dir(_) },
          :factor_dir => { Dir(_) },
          :action => { _ },
        ).merge(
          [:force, :dry_run, :verbose, :trace, :info, :clean, :sums, :remove_old_lock] \
            .map{
              ( (_) => { Bool(_) } )
            }.to_h
        )

        props.each_kv{
            |name, convert|
          self.method( name )( convert( self.options(){ name.replace_all("_", "-") } ) )
        }
        self.verbose(self.verbose || self.dry_run)
        self.trace(self.trace || self.dry_run || self.verbose)

        self.fbash = shell_words::FactorBash(
          self.factor_dir,
          subcommand_output: Bool( ! self.options\{'quiet-subcom'} )
        )

        if (self.remove_old_lock) {
          self.wrn(__LINE__, __METHOD_NAME__, "!!!", "blindly removing old lockfiles (unsafe/debug) [--remove-old-lock | -R]")
        }

        self.locked_fods = Set(self.db, self.factor_dir)

        self._config_setup_done = true
        self.trc(__LINE__, __METHOD_NAME__, "finished configuration, wd now: '#{self.db_path}'")
      }
    }

     method show_info {}
     #  self.config_setup
     #  say "MultiFactor #{self.UUID} options"
     #  say "\tverbose: #{self.verbose}\tinfo: #{self.info}\ttrace: #{self.trace}\tdry_run: #{self.dry_run}"
     #  say "\tclean: #{self.clean}\tsums: #{self.sums}\tdb_name: #{self.db_name}\tdb_path: #{self.db_path}"
     #  say "\tfactor_path: #{self.factor_path}\tdb: #{self.db}\tremove_old_lock: #{self.remove_old_lock}"
     #  say "\tFactor arguments: #{self.factor_arguments}"
     #}

    method capture_write_disk (String caller_name, Block operation) {
      if (! self.dry_run) {
        self.vbs(__LINE__, __METHOD_NAME__, "#{caller_name}: writing disk with", operation)
        return operation.run
      }
      self.vbs(__LINE__, __METHOD_NAME__, "#{caller_name}: not writing disk (dry run)")
      nil
    }

    method read_disk_db () is cached -> Hash {
      self.config_setup
      self.trc(__LINE__, __METHOD_NAME__, 'reading', self.db)

      MultiFactor::_read_disk_db(self.db)
    }

    method load_db () is cached -> Hash {
      self.vbs(__LINE__, __METHOD_NAME__, 'loading db...')
      static const db_data
      if (! defined(db_data)) {
        self.vbs(__LINE__, __METHOD_NAME__, 'wasn\'t cached!')
        db_data = self.read_disk_db
      }
      db_data
    }

    method write_disk_db (Hash new_data) {
      const MN = __METHOD_NAME__
      self.config_setup
      self.trc(__LINE__, MN, 'writing', self.db)

      if ( defined(new_data) && Bool(new_data) && new_data.values.all{_ ~~ BuiltObj} ) {
        self.capture_write_disk(MN, { MultiFactor::_write_disk_db(self.db, new_data) } ) #, __METHOD_NAME__ )
      } else {
        self.cleanup_lock_files
        die "[ERROR]\t#{__METHOD_NAME__}: garbage argument #{new_data}"
      }
    }

    # TODO: don't write the disk right away
    method db_insert (BuiltObj new_entry) {
      self.trc(__LINE__, __METHOD_NAME__, 'inserting', new_entry)
      const entire_db = self.load_db
      entire_db{new_entry.id} = new_entry
      self.write_disk_db( entire_db )
    }

    method db_delete (String id) {
      self.trc(__LINE__, __METHOD_NAME__, 'removing id \'', id, "'")
      const entire_db = self.load_db
      entire_db.delete(id)
      self.write_disk_db( entire_db )
    }


    -> _glue_absolute (t) is cached -> File {
      const File lock_file = File(t.abs+self.lock_ext)

      die "[BUG]\t#{__METHOD_NAME__}: didn't create an absolute path by gluing '#{t}' and '#{self.lock_ext}': #{lock_file}" \
        if (! lock_file.is_abs)
      lock_file
    }

    -> _lock_exists (target, Bool cleanup) {
      const MN = __METHOD_NAME__
      const lock_file = self._glue_absolute(target)

      const Str contents = MultiFactor::atomic_read(lock_file).chomp
      die "[ERROR]\t#{MN}: empty lockfile for target '#{target}'; not safe to continue" \
        if (! contents)

      if (contents == self.UUID) {
        if (! cleanup) {
          die ("[BUG]\t #{MN}: lock file '#{lock_file}' for " +
            "target '#{target}' contains the current process' UUID" +
            "\n\tUnnecessary read; MultiFactor bug found! in #{target.basename}")
        }
        lock_file.remove
        self.vbs(__LINE__, MN, "cleaned up #{lock_file}")
      } else {
        self.vbs(__LINE__, MN, "!! UUID mismatch: #{contents} ≠ #{self.UUID}")
        die (
          "[ERROR]\t#{MN}: lock file '#{lock_file}' for target '#{target}' contains foreign UUID!" +
          "\n\t(only one MultiFactor process should be active in a directory)" +
          "\n\tnot removing it; not continuing"
        )
      }
    }

    -> _do_remove_old_lock {
      if (self.remove_old_lock) {
        self.locked_fods.each{
          const lf = self._glue_absolute(_)
          self.vbs(__LINE__, __METHOD_NAME__, "try to clear old lock file #{lf}")
          lf.exists && (
            lf.remove || self.wrn(__LINE__, __METHOD_NAME__, "can't remove #{lf} for an unknown reason: #{$!}")
          )
        }
      }
    }

    # NOTE: this ensures "we are a running process and we must be the only such running process"
    -> _do_lock_file (target, Bool cleanup) {

      die "[ERROR]\t#{__METHOD_NAME__}: lock target '#{target}' does not exists" \
        if (! target.exists)

      const lock_file = self._glue_absolute(target)

      if (lock_file.exists) {
        self._lock_exists(target, cleanup)
      } else {
        MultiFactor::atomic_write(lock_file, self.UUID)
        self.vbs(__LINE__, __METHOD_NAME__, "created #{lock_file}")
      }
    }

    method do_lock_files {
      self.config_setup
      self._do_remove_old_lock
      self.trc(__LINE__, __METHOD_NAME__, "locking FODs: #{self.locked_fods.join(', ')}")
      self.locked_fods.each{
          |target|
        self._do_lock_file( target, false )
      }
      self.vbs(__LINE__, __METHOD_NAME__, "done locking FODs!")
    }

    method cleanup_lock_files {
      self.config_setup
      self.trc(__LINE__, __METHOD_NAME__, "cleanup lock files for FODs: #{self.locked_fods.join(', ')}")
      self.locked_fods.each{
          |target|
        self._do_lock_file( target, cleanup: true )
      }
      self.vbs(__LINE__, __METHOD_NAME__, "cleaned up lock files!")
    }

    -> compile_vm (File vm_name) -> Bool {
      if ( ! self.fbash.build_factor(vm_name) ) {
        self.cleanup_lock_files
        die "vm compilation failed!"
      }
      true
    }

    -> compile_image (File vm_name, File image_name) -> Bool {
      if (! self.fbash.build_image(vm_name, image_name) ) {
        self.cleanup_lock_files
        die "image compilation failed!"
      }
      true
    }

    -> _blob_file_contents_sum (File f, Str algo = null) {
      if (algo == null) { algo = self.sum_blob_algo }
      # const fname = (f.is_abs ? f : self.fbash.wd+f)
      self.vbs(__LINE__, __METHOD_NAME__, "checksumming #{f}")
      f |> :open_r |> :slurp |> (:encode, :utf8) |> algo
    }

    -> current_status_to_builtobj (Hash status) -> BuiltObj {
      self.vbs(__LINE__, __METHOD_NAME__, 'creating BuiltObj from scratch')
      var bo = BuiltObj().id(self.UUID)
      status.keys.each{
          |prop|
        # self.vbs(__LINE__, __METHOD_NAME__, "invoke method / property '#{prop}'")
        bo.method(prop)( status{prop} )
      }
      self.vbs(__LINE__, __METHOD_NAME__, 'setting creation time')
      bo.time_created(Time.now)
    }

    -> build_new_factor (Hash current_status) {
      const MN = __METHOD_NAME__
      self.trc(__LINE__, MN, 'no match in db!')
      # interpret the current_status keys as property (setter) names in BuiltObj
      # this call does not set all properties, only those listed in status_properties
      const BuiltObj building_obj = self.current_status_to_builtobj(current_status)

      # take the vm file name and compile it, then checksum it
      building_obj.vm_fullname -> cleave(
        { |n| self.compile_vm(n) },
        { |n| building_obj.vm_blob_sum( self._blob_file_contents_sum(n) ) }
      )

      # in sane configuration, the image won't have a prefix because Factor
      #   really doesn't like when the VM and image don't have the same
      # filename before the ".image"
      building_obj.image_fullname -> cleave(
        { |n| self.compile_image(building_obj.vm_fullname, n) },
        { |n| building_obj.image_blob_sum( self._blob_file_contents_sum(n) ) }
      )

      # no more changes
      building_obj.lock

      self.trc(__LINE__, MN, 'writing the new BuiltObj to disk db because it changed')
      self.insert_disk_db(building_obj)
      self.trc(__LINE__, MN, "ok, running factor!")
      self.cleanup_lock_files
      return self._detach_factor_thread(building_obj.vm_fullname)
    }

    # multifactor's actual entry point
    # TODO: make this asynchronous, so that with_directory stuff is
    # done in a separate actor and awaited

    # DONE: dynamic hash algo selection
    # TODO: read mtimes
    # TODO: write mtime/atimes
    # TODO: testability
    # DONE: if branches
    # DONE: make use of git information
    # DONE: compare OS, ARCH, WORD SIZE information
    # TODO: image compression?
    method go (Bool is_restart = false) {
      const MN = __METHOD_NAME__
      self.config_setup
      if (self.info) { self.show_info; return nil }

      self.do_lock_files

      given (self.action) {
        when ('src-sums') {
          self.fbash.say_src_sums
          return self.cleanup_lock_files
        }
        when ('env-info') {
          self.fbash.say_env_info
          return self.cleanup_lock_files
        }
      }

      # property names in BuiltObj, used to create current_status
      # BuildSh and FactorBash implement these through FactorBash.delegate
      const status_properties = [
        :factor_version, :git_branch, :git_hash, :is_git,
        :os_type, :os_name, :arch_name, :word_size, :vm_ext,
        # the block is called for its default value but without arguments,
        #   because a "normal" version of the :sum_algorithm method in FactorBash
        #   requires knowledge of its containing class
        # this allows setting the blob checksum algorithm from the command line arguments
        [ :sum_algorithm, default: { self.sum_blob_algo } ],
        # this allows setting the SrcSums checksum algorithm for the VM on the command line
        [ :vm_sums, args: (algo: self.sum_src_algo) ],
        [ :image_sums, args: (algo: self.sum_src_algo) ],
      ]
      subset ArrStr < String, Array
      # makes Array<String, default?, args?> into String
      -> undefault_single (prop < ArrStr) -> String { [@|prop] -> first }
      # makes Array<Array<String, default?, args?>> into Array<String>
      -> undefault (Array props) -> Array { props.map{ undefault_single(_) } }

      # current_status is a Hash representing current disk / system config
      # it maps string property names in status_properties to the result of
      #   determining their values through FactorBash.delegate
      # '@|' is like '...' but only calls '...' when the object can recieve it
      const current_status = status_properties.map{ |n| (undefault_single(n), self.fbash.delegate(@|n)) }.to_h
      const db_data = self.load_db
      if (self.debug) {
        say current_status
        say db_data
      }

      const builtobj_matching = db_data.values.find{
          |b|
        # compare_properties just wants the Array<String> as its basis for
        #   comparing properties
        # we're done with the status_properties Array<String, default?, args?>
        #  now but it may come in handy

        # remember, we're not testing *all* properties like .lock or tombstoned
        MultiFactor::compare_properties(undefault(status_properties), b, current_status, debug: self.debug)
      }

      # need to generate new ID and compile
      if (! builtobj_matching) {
        return self.build_new_factor(current_status)
      }

      # now this is definitely defined
      builtobj_matching.lock

      if (builtobj_matching.time_tombstoned != 'never') {
        say '!!! matching entry is tombstoned!'
        # need to trash the old entry
        ...
        self.build_new_factor(current_status)
      }

      self.vbs(__LINE__, MN, 'matching object in db')
      const (
        # tehcnically breaks concern separation by using full paths instead of with_directory
        # but this is an optimisation; we want to minimise chdirs
        # note: ignoring BuiltObj.vm_base_name here because it doesn't make any sense
        matching_vm_name = self.fbash.wd+File(builtobj_matching.vm_fullname),
        matching_image_name = self.fbash.wd+File(builtobj_matching.image_fullname)
      )

      var (
        current_blob_sums = Hash(),
        new_recompiled = Hash(
          :vm => if (! (self.fbash.wd + matching_vm_name -> exists) ) {
            self.trc(__LINE__, MN, "vm named '#{matching_vm_name}' doesn't exist: compiling")
            self.compile_vm(matching_vm_name)
          },

          :image => if (! (self.fbash.wd + matching_image_name -> exists) ) {
            self.trc(__LINE__, MN, "image named '#{matching_image_name}' doesn't exist: compiling")
            self.compile_image(matching_vm_name, matching_image_name)
          }
        )
      )

      # this exists so we can check the blob sums without having to use scoped assignment
      -> do_blob_sums (String type, File blob) {
        const sum = self._blob_file_contents_sum(blob, algo: builtobj_matching.sum_algorithm || self.sum_blob_algo)
        const property = type+:_blob_sum
        Hash(
          (property) => sum,
          (type+:_matches) => ( sum == builtobj_matching.method(property)() )
        ).cleave(
          { say "#{property}: #{builtobj_matching.method(property)()} #{_}" if (self.debug) },
          { current_blob_sums.merge!(_) }
        ).last
      }

      do_blob_sums(:vm, matching_vm_name)
      do_blob_sums(:image, matching_image_name)

      new_recompiled.merge!(
        if (! [current_blob_sums{:vm_matches, :image_matches}].all{ _ } ) {
          # due to different compiler versions
          self.trc(__LINE__, MN, 'blob sums mismatch!')
          # ???
          Hash(
            :vm => new_recompiled{:vm} || if (! current_blob_sums{:vm_matches}) {
              self.trc(__LINE__, MN, 'recompiling VM!')
              self.compile_vm(matching_vm_name) -> cleave(
                { do_blob_sums(:vm, matching_vm_name) },
                { _ }
              ).last
            },
            :image => new_recompiled{:image} || if (! current_blob_sums{:image_matches}) {
              self.trc(__LINE__, MN, 'recompiling image!')
              self.compile_image(matching_vm_name, matching_image_name) -> cleave(
                { do_blob_sums(:image, matching_image_name) },
                { _ }
              ).last
            }
          )
        } else { Hash() }
      )
      # blob sums have been implicitly re-checked

      # if they STILL don't match, delete the files + tombstone the entry and quit
      if ( ! [current_blob_sums{:vm_matches, :image_matches}].all{ _ } ) {
        self.trc(__LINE__, MN, 'blob sums still mismatched!')
        if (is_restart) {
          self.trc(__LINE__, MN, "i give up");
          return self.cleanup_lock_files
        }
        self.trc(__LINE__, MN, "starting over...")
        const tombstone_builtobj = (builtobj_matching |> :dclone |> :unlock)
        del builtobj_matching
        tombstone_builtobj.time_tombstoned(Time.now)

        self.insert_disk_db(tombstone_builtobj)
        self.capture_write_disk(MN, { matching_vm_name.remove, matching_image_name.remove })
        self.go(is_restart: true)
      }

      # OK, going to update the DB and run Factor

      # only updating the blob sums IFF the blob was newly compiled
      # otherwise, just update the mod/access times and run count
      const new_builtobj_matching = builtobj_matching.cleave( { .lock }, { .dclone } ).last
      if (new_recompiled{:vm}) {
        self.vbs(__LINE__, MN, 'writing memory BuiltObj because of the newly compiled VM')
        new_builtobj_matching.vm_blob_sum(current_blob_sums{:vm})
      }
      if (new_recompiled{:image}) {
        self.vbs(__LINE__, MN, 'writing memory BuiltObj because of the newly compiled image')
        new_builtobj_matching.image_blob_sum(current_blob_sums{:image})
      }
      if ( [new_recompiled{:vm, :image}].any{ _ } ) {
        new_builtobj_matching.time_modified(Time.now)
      }

      new_builtobj_matching.lock

      const changed_db = if (builtobj_matching != new_builtobj_matching) {
        self.trc(__LINE__, MN, 'writing the new BuiltObj to disk db because it changed')
        self.insert_disk_db(new_builtobj_matching)
        true
      }

      # say "Eventual successful configuration!"
      # say "\tmatching_vm_name:\t'#{matching_vm_name}' # #{disk_vm_sum[0..10]}...\tmatching_image_name:\t'#{matching_image_name}' #{disk_image_sum[0..10]}..."
      # say "\tvm_sums_match:\t\t#{vm_blob_sums_match}/#{new_vm_blob_sums_match}"
      # say "\timage_sums_match:\t#{image_blob_sums_match}/#{new_image_blob_sums_match}"
      # say "\tchanged_db:\t\t#{changed_db}\t\t\tnewly_compiled: #{newly_compiled.to_s.chars.grep{|p|![\"\n\",' '].any{p==_} }.join}"
      self.trc(__LINE__, MN, "ok, running factor!")
      self.cleanup_lock_files
      self._detach_factor_thread(matching_vm_name)
    }

    -> _detach_factor_thread (String vm_name) {
      const MN = __METHOD_NAME__
      {
        self.inf(__LINE__, MN, 'Launching Factor: ', "'", vm_name, self.factor_arguments..., "'")
        if (! self.fbash.with_directory{
          Command::spawn_se('./' + vm_name, self.factor_arguments..., output: true)
        } ) {
          self.inf(__LINE__, MN, "Failed: #{$!}")
        }
      }.thr.detach
      # don't segfault
    }

    BuiltObj(_arch_name: "x86",
   _factor_version: "0.99",
   _fail: "attempted writing to locked BuiltObj object!",
   _git_branch: "master",
   _git_hash: "29da71e2bf7d7fc40333752ae692b2b6bd71214e",
   _id: "MsgIQ-LH,UyQ8DrisbehfDTzoXlCaBMu",
   _image_blob_sum: "28c843c09a71e948143e3f3c029abbb8254002f8abcdbf9ef1e1f2a223ed7849",
   _image_ext: ".image",
   _image_prefix: "fvm_",
   _image_sums: SrcSums(algo: "sha256",
   contents: "75cc4b2449fdb5f1326b0f82829ef8a1b257d1567fdfbdde29dd1474802de2f6",
   names: "dc1af79c46263717d94f506b2dc210b0b3c1235f3893f041eefd13544c3c457d"),
   _is_git: true,
   _lk: true,
   _os_name: "linux",
   _os_type: "unix",
   _sum_algorithm: "sha256",
   _time_accessed: 0,
   _time_created: 1550446425,
   _time_modified: 0,
   _time_tombstoned: "never",
   _vm_blob_sum: "7af658bd07353264cd2fbfc905f05eb0615b8727381aa6b12b0eaaec9649a5e9",
   _vm_ext: "",
   _vm_prefix: "fvm_",
   _vm_sums: SrcSums(algo: "sha256",
   contents: "84523dd7e230e9d13958b20a529e169098ba45f7320f3b97d64f104e4934799b",
   names: "ee881ad2f6a4cdaf3fe6b9e6a2101cdf6bc0e0c39fd47c0dd506b1689574af20"),
   _word_size: "64")
  }
}

define MICRO_MAGNITUDE = 1_000
func μsec { Time.micro*MICRO_MAGNITUDE }
func μsec (Number n) { Time.micro*MICRO_MAGNITUDE - n }

func main {
  const μs = μsec()
  μs
  # say Factor::RC_FILE
  # say Factor::REPO
  # say Factor::VERSION
  # say Dir.cwd
  # say Dir.cwd
  # Dir.chdir(Factor::REPO)
  # say BuildSh::generate_make_targets()
  # say FactorBash::sum_git_names_matching(/\.s(?:m|f)/)
  # say FactorBash::sum_git_contents_matching(/\.s(?:m|f)/)
  # say MultiFactor::BuiltObj(([""] * 15)..., false ).dump.len

  const parser = argparse::ArgParse(ARGV) \
    .info(SCRIPT) \
    .option("force", "f", doc: "Force a rebuild in any case") \
    .option("trace", "t", doc: "Some debug tracing") \
    .option("verbose", "V", doc: "Verbose debug tracing") \
    .option("info", "i", doc: "Just show configuration information") \
    .option("dry-run", "n", doc: "Change no disk files") \
    .option("clean", "c", negate: "Always":"Never", doc: "'make clean'") \
    .option("sums", "s",  negate: "Always":"Never", doc: "use checksums") \
    # probably don't need this, or set it in config file
    # .option("sum-len", "l", param: "len":"12", doc: "Shorten checksums to this length") \
    .option("db-name", "D", param: "name":".multifactor.db", doc: "Custom database filename") \
    .option("db-path", "d", param: "path":".", doc: "Path to dir containing database") \
    .option("factor-dir", "w", param: "path":".", doc: "Path to Factor working directory") \
    .option("remove-old-lock", "R", doc: "Blindly remove any lock files (unsafe!)") \
    .option("quiet-subcom", "q", negate: "Never":"Always", doc: "show subcommand outputs") \
    .option(
      "action", "a", param: "name":"run-factor",
      doc: "Perform this action\nactions: run-factor, src-sums, env-info"
    ) \
    .use_option_terminator("Further arguments are given to Factor") \
    # .use_stdin_file_arg \
    # .use_arg_list_terminator \
    # .ignore_unknowns \
    # .help_on_stderr \
    .arg("arg...", doc: "Arguments to the final Factor VM")

  var (opts, args, *_) = parser.go...
  # say "#{opts} #{args} #{_}"

  const r = MultiFactor::Runtime(opts, args.keys)

  # r.show_info()
  r.go()

  Factor::say_stderr("\n\tΔ#{μsec(μs)} ×1,000μ")
}

if (__FILE__ == __MAIN__) {
  main()
}
