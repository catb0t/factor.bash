#!ruby
include frext

func process_serial_prop_rhs (callers < frext::ArrStr, String name, Object obj, typename, default_val, custom_blocks) {
  const FN = __FUNC_NAME__
  ([typename, default_val, custom_blocks].any{ !defined(_) || _==null } &&
    die "invalid argument list for #{__FUNC_NAME__}")

  const is_fqa = TypeUtils::is_a_fqco(obj, Array, must_have_prop: :merge_reduce)

  # maybe the following can be vectorised?

  if ( !is_fqa ) {
    TypeUtils::is_typename(obj) || die ('RHS in serial property declaration \''+name.dump+'\' isn\'t a typename: \''+obj.dump+'\' (perhaps you accidentally initialised the object?)')
    *typename      = obj
    *default_val   = TypeUtils::maybe_call_custom_init([@|callers, FN, :V_obj_is_simple], obj )
    *custom_blocks = Hash()

  } else {
    die (
      "#{__FILE__}:#{__LINE__}: #{FN}: malformed array in RHS when declaring field '#{name}': must have positive length (1, 2 or 3)"
    ) if ( is_fqa && !obj )

    if (obj.len == 1) {
      __FUNC__(name, obj[0], typename, default_val, custom_blocks )
    } else {
      defined(obj[2]) && ( TypeUtils::is_a_fqco(obj[2], Hash) \
        || die "#{__FILE__}:#{__LINE__}: #{FN}: malformed custom get/set blocks in RHS when declaring field '#{name}': RHS item \#3: want type 'Hash'; got '#{obj[2].ref}'"
      )

      *typename      = obj[0]
      *default_val   = obj[1] \\ TypeUtils::maybe_call_custom_init([@|callers, FN, :V_obj_is_fqa], obj[1] )
      *custom_blocks = obj[2] \\ Hash()
    }
  }
}

class Serializable {
  has String _k_svalue = :_serial_value

  -> _grep_serial_properties (Array excl) is cached -> Hash {
    self.grep_methods{ |name, _| name ~~ /^serial_properties/ } \
      .values \ # Array<LazyMethod>
      # not a constructor; just a method call on self.serial_properties*
      .map{
        _().grep_kv{ |name, _| !excl.contains(name) }
      } \
      .merge_reduce \\ Hash()
  }

  -> _do_serial (Array exclude, Block d) {
    self._grep_serial_properties(exclude).map_kv(d)
  }

  -> _is_serialized_obj (Object obj) {
    (
      TypeUtils::is_a_fqco(obj, Hash, must_have_prop: :merge) &&
      obj.keys==[self._k_svalue] &&
      TypeUtils::is_a_fqco( obj{self._k_svalue}, Hash, must_have_prop: :merge )
    )
  }

  method serialize (Array exclude = [], Bool _recursing = false) -> Hash {
    const MN = __METHOD_NAME__
    const RC = (_recursing ? :R_recursing : :R_not_recursing)

    self._do_serial(exclude, {
        |field_name, field_rhs|

      process_serial_prop_rhs([MN, RC, :V_first_step], field_name, field_rhs, \var typename, \var default_val, \var _)

      var type
      const value = (if ( self.is_property([MN, RC, :V_find_getter, :V_is_prop], field_name, default_val) ) {
        type = :property
        self{field_name}
      } elsif (
        self.has_overload( Hash(
          :callers => [MN, RC, :V_find_getter, :V_is_mth],
          :name => field_name,
          :retval_ref => \var Object prelim_val
        ) )
      ) {
        type = :getter
        prelim_val
      } else {
        die ("#{__FILE__}:#{__LINE__}: #{__METHOD_NAME__}: #{field_name} (#{typename}) " + 'appears to be neither a property nor declared getter')
      } \\ default_val)
      # say "serialize '#{field_name}': type '#{type}': value: #{value}"

      # assert(defined(value), "#{__FILE__}:#{__LINE__}: Assertion `self.#{field_name} != nil' failed!")

      ( (field_name) => (
        TypeUtils::is_serializable(value)
          ? Hash( (self._k_svalue) => value.serialize( exclude: exclude, _recursing: true ) )
          : value
      ) )
    })
  }

  method unserialize (Hash data, Array exclude = [], Bool _recursing = false, /* eval_scope = { eval(_) } */ ) -> __CLASS__ {
    const MN = __METHOD_NAME__
    const RC = (_recursing ? :R_recursing : :R_not_recursing)

    self._do_serial(exclude, {
        |field_name, field_rhs|
      process_serial_prop_rhs([MN, RC, :V_first_step], field_name, field_rhs, \var typename, \var default_val, \var _)

      const entry = data{field_name}

      if ( ! self._is_serialized_obj(entry) ) {
        entry
      } else {
        TypeUtils::maybe_call_custom_init([MN, RC, :V_find_value, :V_is_serialized], default_val ).unserialize(
          entry{self._k_svalue},
          exclude: exclude,
          _recursing: true
          # eval_scope: eval_scope
        )
      }.in_scope{
          |derived|
        if ( self.is_property([MN, RC], field_name, derived) ) {
          self{field_name} = derived
        } else {
          # the well-behaved setter returns `self'
          const Bool res = self.has_overload( Hash(
            :callers => [MN, RC, :V_find_setter],
            :name => field_name,
            # :retval_ref => \var Object retval,
            :args => [derived]
          ) )

          # say "res: #{res} retval: #{retval.dump} value now: #{self.method(field_name)().dump}"
          #if ( res  ) {
          #  const own_class = eval_scope( TypeUtils::fqtn_to_umdtn(self.ref) )
          #  assert(
          #   TypeUtils::is_a_fqco( retval, own_class ),
          #   (
          #     "#{__FILE__}:#{__LINE__}: #{__METHOD_NAME__}: malformed setter " +
          #     "for '#{field_name}': setters must return 'self' (arg: #{derived})"
          #   )
          #  )
          if ( !res ) {
            die ("#{__FILE__}:#{__LINE__}: #{__METHOD_NAME__}: #{field_name} (#{typename}) (value #{derived}) " + 'appears to be neither a property nor declared setter')
          }
        }
        # say "unserialize '#{field_name}': type '#{type}': was serialized: #{sd}: value: #{derived}"
      } # endif
    })
    self
  }
}

# use the serializable functionality to equate two objects
/* abstract interface */ # /
class SeriallyEquatable < Serializable {
  -> _serial_eq (other, exclude_props = []) -> Bool {

    if ( other.is_a(Serializable) ) {
      other.serialize(exclude: exclude_props) == self.serialize(exclude: exclude_props)

    # somehow... maybe other is our superclass
    } elsif (other ~~ self) {
     [self, other].map{
       |obj| self._do_serial(exclude_props, { obj.method(_)() } )
     }«==»

    } else { self._do_serial(exclude_props, { other{_} == self{_} } ).all }
  }
  method == (other) { self._serial_eq(other) }
}


func _call_methods_blocks_by (Object obj, Regex r) {
  obj.grep_map_methods(
    { |name, _| name ~~ r },
    { |_, calls| calls().each{ |block| block.run(obj) } }
  )
}

class ModularInit {
  method init {
    _call_methods_blocks_by(self, /^init_steps/)
    self
  }
}


const Array global_init_steps_sa_base = [
  { ._do_serial([], ._bound_accessor_generator ) }
]

class SeriallyAccessible << ModularInit, SeriallyEquatable {
  has Array init_steps_sa_base = global_init_steps_sa_base
  method _bound_accessor_generator {
    const MN = __METHOD_NAME__
    {
        |field_name, field_rhs|

      process_serial_prop_rhs([MN, :V_bound_block, :V_first_step], field_name, field_rhs, \var Object typename, \var Object default_val, \var Hash custom_blocks)

      (typename ~~ default_val) \
        || die (
          "#{__FILE__}:#{__LINE__}: #{__METHOD_NAME__}: type mismatch when generating default value for '#{field_name}': ",
          "want '#{typename}'; got '#{default_val.class}' ('#{default_val.dump}')"
      )

      die 'class already has raw property named \''+field_name.dump+'\' (did you forget to declare the raw property with \'_'+field_name+'\'?)' if ( self.is_property([MN, :V_bound_block], field_name, default_val) )

      # create the private slot
      # say "#{__METHOD_NAME__}: setting _#{field_name} to '#{default_val.dump}'"
      self{:_ + field_name} = default_val
      # say "#{__METHOD_NAME__}: set _#{field_name}"

      const Block setter_prelude = {
        .is_a(typename) \
          || die(
            "#{__FILE__}:#{__LINE__}: #{__METHOD_NAME__}:  ",
            "type mismatch in generated setter '#{field_name}': want '#{typename}'; got '#{_.class}'  ('#{_.dump}')"
        )
      }


      func acc (self) {
        # say "get field #{field_name}"
        # say "custom_blocks: #{custom_blocks}"
        static var custom_getter = custom_blocks{:get}
        # say "get field #{field_name} (#{typename}) with #{custom_getter}"
        if (custom_getter) { custom_getter.run(self) } else { self{:_ + field_name} }
      }

      func acc (self, new_val) {
        static var custom_setter = custom_blocks{:set}
        setter_prelude.run(new_val)
        # say "set field #{field_name} to #{new_val} (#{typename})"
        if (custom_setter) { custom_setter.run(self, new_val) \\ self } else { self{:_ + field_name} = new_val; self }
      }
      __CLASS__.def_method(field_name, acc)
      # say "declared accessor for #{field_name}"
    }
  }

  method _property_generator {
    define Regex serial_pg_name = /^serial_property_generator([_\w]+)$/
    self.grep_methods( { _ ~~ serial_pg_name } ) \
      .each_kv{
            |name, calls|
          say "createproperty #{name} => calls #{calls}"
          __CLASS__.def_method(
            :serial_properties + (name =~ serial_pg_name)[0],
            func curried (self) { calls().run(self) }
          )
      }
  }
}


class Lockable {
  has Bool _impl_locked = false
  has String _impl_err_write_locked = 'attempt of write to locked '+__CLASS_NAME__+' object!'

  -> lock { self._impl_locked = true }
  -> lock (Bool b) { self._impl_locked = b }
  -> unlock { self._impl_locked = false }
}
