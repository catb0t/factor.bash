#! ruby
subset ArrStr < Array, String { .len }

class Object {
  # method form of "with"
  method in_scope (b) { b.run(self) }
  method cleave (*b) { b.map{ .run(self) } }

  # internal; doesn't care about overloads
  /* -> respond_to (String name, *_) -> Bool { self.can(name, _...) } */

  method declares_method (String name) -> Hash {
    self.grep_methods{ |n, _| n ~~ name }
  }

  # test if it can be called with the specific number and type of arguments
  method has_overload (Hash overload_spec) -> Bool {
    ( Hash(
      :clone_call => false,
      :catch_msg_ref => null,
      :retval_ref => null,
      :args => []
    ) + overload_spec ).in_scope{
        |spec|
      die 'invalid has_overload spec: \'callers\' must be a non-empty array of non-empty strings' \
        if ( ! spec{:callers}.cleave( { _ }, { .is_an(Array) }, { .all }, { .all{ .is_a(String) } } ).all  )

      const invalid_caller = 'invalid has_overload spec from ('+spec{:callers}.join(' > ')+'): '

      die invalid_caller+'\'name\' must be nonempty string' \
        if ( ! spec{:name}.cleave( { _ }, { .is_a(String) }, { .respond_to(:len) } ).all )

      die invalid_caller+'\'args\' must be iterable' \
        if ( ! spec{:args}.respond_to("...") )

      try {
        say "\t** has_overload < (#{spec{:callers}.reverse.join(' < ')}):\n\t\t.method( '#{spec{:name}}' )( #{spec{:args}.map{.dump}.join(', ')} ) ;; clone_call: #{spec{:clone_call}} catch_msg_ref: #{spec{:catch_msg_ref}} retval_ref: #{spec{:retval_ref}}"
        const r = ( spec{:clone_call} ? self.dclone : self).method( spec{:name} )( spec{:args}... )
        if (null != spec{:retval_ref}) { *( spec{:retval_ref} ) = r }
        say "\t\t\tinvocation worked!"
        true
      } catch {
          |_e, msg|
        print "\t\t\t"+'invocation failed! reason: '
        if (msg.len > 120) { say "#{@|msg.first(50)} ... #{@|msg.last(70)}" } else { say "#{msg}" }
        if (null != spec{:catch_msg_ref}) { *( spec{:catch_msg_ref} ) = msg }
        false
      }
    }
  }

  # declared, exists, can be called
  method has_public_concrete_method (callers < ArrStr, String name) {
    self.cleave(
      { .respond_to(name) },
      { .declares_method(name) },
      {
        .has_overload( Hash(
          :callers => [@|callers, __METHOD_NAME__],
          :name => name,
          :clone_call => true,
          :catch_msg_ref => \var String msg
        ) ) || (msg ~~ /does not match/)
      }
    ).all
  }

  method has_public_concrete_overload (callers < ArrStr, Str name, *args) {
    self.cleave(
      { .respond_to(name) },
      { .declares_method(name) },
      {
        .has_overload( Hash(
          :callers => [@|callers, __METHOD_NAME__],
          :name => name,
          :clone_call => true,
          :catch_msg_ref => \var String msg,
          :args => args)
        ) || (msg !~ /does not match/)
      }
    ).all
  }

  method is_property (callers < ArrStr, Str name, Object type_example_arg) {
    # self-respecting explicitly declared accessors are typed, and not varargs
    # field accessors generated with "has X" are untyped varargs
    self.has_overload( Hash(
      :callers => [@|callers, __METHOD_NAME__],
      :name => name,
      :clone_call => true,
      :catch_msg_ref => \var String msg,
      :args => [type_example_arg, :extra_garbage_arg]
    ) ) && (/does not match/ !~ msg)
  }

  method grep_methods (Block b) {
    self.methods.grep_kv(b)
  }
  method grep_map_methods (Block g, Block m) {
    self.grep_methods(g).map_kv(m)
  }
}

class Array {
  method all { self.all{ _ } }
  method merge_reduce { self.reduce{ |l, r| l.merge(r) } }
}

module TypeUtils {
  func is_serializable (Object obj) {
    obj.respond_to(:serial_properties)
    # obj.has_overload( Hash( :callers => __FUNC_NAME__, :name => :serial_properties) )
  }
  # Fully-Qualified Sidef::Runtime:92349879234::main::Typename Typename
  #   to Universal Main-Derived Typename main::Typename
  func fqtn_to_umdtn (String fqtn) -> String {
    (/^Sidef::Runtime::\d+::(main::.+)$/ =~ fqtn)[0]
  }

  func is_typename (Object obj) -> Bool {
    [:compile_to_perl, :code_interactive].all{ obj.declares_method(_) } && obj.refaddr==0
  }

  # is Fully-Qualified Constructed Object
  func is_fqco (obj, must_have_prop = false) -> Bool {
  # say "is fqco #{obj} #{must_have_prop}"
    Bool( !is_typename(obj) && (obj.refaddr != 0) && (must_have_prop ? obj.declares_method(must_have_prop) : true) )
  }

  func is_a_fqco (obj, typename, must_have_prop = false) {
  # say "is a + is fqco #{obj} #{typename} #{must_have_prop}"
    obj.is_a(typename) && TypeUtils::is_fqco(obj, must_have_prop: must_have_prop)
  }

  func maybe_call_custom_init (callers < ABCs2::ArrStr, Object obj) {
    if ( /* obj.has_overload( Hash(
        :callers => [@|callers, __FUNC_NAME__],
        :name => :INIT_METHOD_NAME) ) */
        obj.respond_to(:INIT_METHOD_NAME)
    ) {
      obj.method( obj.INIT_METHOD_NAME )()
    } elsif ( TypeUtils::is_typename(obj) ) {
      # invoke raw typenames
      obj()
    } else {
      obj
    }
  }
}

func process_serial_prop_rhs (callers < ArrStr, String name, Object obj, typename, default_val, custom_blocks) {
  const FN = __FUNC_NAME__
  ([typename, default_val, custom_blocks].any{ !defined(_) || _==null } &&
    die "invalid argument list for #{__FUNC_NAME__}")

  const is_fqa = TypeUtils::is_a_fqco(obj, Array, must_have_prop: :merge_reduce)

  # maybe the following can be vectorised?

  if ( !is_fqa ) {
    TypeUtils::is_typename(obj) || die ('RHS in serial property declaration \''+name.dump+'\' isn\'t a typename: \''+obj.dump+'\' (perhaps you accidentally initialised the object?)')
    *typename      = obj
    *default_val   = TypeUtils::maybe_call_custom_init([@|callers, FN, :V_obj_is_simple], obj )
    *custom_blocks = Hash()

  } else {
    die (
      "#{__FILE__}:#{__LINE__}: #{FN}: malformed array in RHS when declaring field '#{name}': must have positive length (1, 2 or 3)"
    ) if ( is_fqa && !obj )

    if (obj.len == 1) {
      __FUNC__(name, obj[0], typename, default_val, custom_blocks )
    } else {
      defined(obj[2]) && ( TypeUtils::is_a_fqco(obj[2], Hash) \
        || die "#{__FILE__}:#{__LINE__}: #{FN}: malformed custom get/set blocks in RHS when declaring field '#{name}': RHS item \#3: want type 'Hash'; got '#{obj[2].ref}'"
      )

      *typename      = obj[0]
      *default_val   = obj[1] \\ TypeUtils::maybe_call_custom_init([@|callers, FN, :V_obj_is_fqa], obj[1] )
      *custom_blocks = obj[2] \\ Hash()
    }
  }
}

class Serializable {
  has String _k_svalue = :_serial_value

  -> _grep_serial_properties (Array excl) is cached -> Hash {
    self.grep_methods{ |name, _| name ~~ /^serial_properties/ } \
      .values \ # Array<LazyMethod>
      # not a constructor; just a method call on self.serial_properties*
      .map{
        _().grep_kv{ |name, _| !excl.contains(name) }
      } \
      .merge_reduce \\ Hash()
  }

  -> _do_serial (Array exclude, Block d) {
    self._grep_serial_properties(exclude).map_kv(d)
  }

  -> _is_serialized_obj (Object obj) {
    (
      TypeUtils::is_a_fqco(obj, Hash, must_have_prop: :merge) &&
      obj.keys==[self._k_svalue] &&
      TypeUtils::is_a_fqco( obj{self._k_svalue}, Hash, must_have_prop: :merge )
    )
  }

  method serialize (Array exclude = [], Bool _recursing = false) -> Hash {
    const MN = __METHOD_NAME__
    const RC = (_recursing ? :R_recursing : :R_not_recursing)

    self._do_serial(exclude, {
        |field_name, field_rhs|

      process_serial_prop_rhs([MN, RC, :V_first_step], field_name, field_rhs, \var _, \var default_val, \var _)

      var type
      const value = (if ( self.is_property([MN, RC, :V_find_getter, :V_is_prop], field_name, default_val) ) {
        type = :property
        self{field_name}
      } elsif (
        self.has_overload( Hash(
          :callers => [MN, RC, :V_find_getter, :V_is_mth],
          :name => field_name,
          :retval_ref => \var Object prelim_val
        ) )
      ) {
        type = :getter
        prelim_val
      } else {
        die ("#{__FILE__}:#{__LINE__}: #{__METHOD_NAME__}: #{field_name} (#{typename}) " + 'appears to be neither a property nor declared getter')
      } \\ default_val)
      # say "serialize '#{field_name}': type '#{type}': value: #{value}"

      # assert(defined(value), "#{__FILE__}:#{__LINE__}: Assertion `self.#{field_name} != nil' failed!")

      ( (field_name) => (
        TypeUtils::is_serializable(value)
          ? Hash( (self._k_svalue) => value.serialize( exclude: exclude, _recursing: true ) )
          : value
      ) )
    })
  }

  method unserialize (Hash data, Array exclude = [], Bool _recursing = false, /* eval_scope = { eval(_) } */ ) -> __CLASS__ {
    const MN = __METHOD_NAME__
    const RC = (_recursing ? :R_recursing : :R_not_recursing)

    self._do_serial(exclude, {
        |field_name, field_rhs|
      process_serial_prop_rhs([MN, RC, :V_first_step], field_name, field_rhs, \var typename, \var default_val, \var _)

      const entry = data{field_name}

      if ( ! self._is_serialized_obj(entry) ) {
        entry
      } else {
        TypeUtils::maybe_call_custom_init([MN, RC, :V_find_value, :V_is_serialized], default_val ).unserialize(
          entry{self._k_svalue},
          exclude: exclude,
          _recursing: true
          # eval_scope: eval_scope
        )
      }.in_scope{
          |derived|
        if ( self.is_property([MN, RC], field_name, derived) ) {
          self{field_name} = derived
        } else {
          # the well-behaved setter returns `self'
          const Bool res = self.has_overload( Hash(
            :callers => [MN, RC, :V_find_setter],
            :name => field_name,
            :retval_ref => \var Object retval,
            :args => [derived]
          ) )

          # say "res: #{res} retval: #{retval.dump} value now: #{self.method(field_name)().dump}"
          #if ( res  ) {
          #  const own_class = eval_scope( TypeUtils::fqtn_to_umdtn(self.ref) )
          #  assert(
          #   TypeUtils::is_a_fqco( retval, own_class ),
          #   (
          #     "#{__FILE__}:#{__LINE__}: #{__METHOD_NAME__}: malformed setter " +
          #     "for '#{field_name}': setters must return 'self' (arg: #{derived})"
          #   )
          #  )
          if ( !res ) {
            die ("#{__FILE__}:#{__LINE__}: #{__METHOD_NAME__}: #{field_name} (#{typename}) (value #{derived}) " + 'appears to be neither a property nor declared setter')
          }
        }
        # say "unserialize '#{field_name}': type '#{type}': was serialized: #{sd}: value: #{derived}"
      } # endif
    })
    self
  }
}

# use the serializable functionality to equate two objects
/* abstract interface */ # /
class SeriallyEquatable < Serializable {
  -> _serial_eq (other, exclude_props = []) -> Bool {

    if ( other.is_a(Serializable) ) {
      other.serialize(exclude: exclude_props) == self.serialize(exclude: exclude_props)

    # somehow... maybe other is our superclass
    } elsif (other ~~ self) {
     [self, other].map{
       |obj| self._do_serial(exclude_props, { obj.method(_)() } )
     }«==»

    } else { self._do_serial(exclude_props, { other{_} == self{_} } ).all }
  }
  method == (other) { self._serial_eq(other) }
}


func _call_methods_blocks_by (Object obj, Regex r) {
  obj.grep_map_methods(
    { |name, _| name ~~ r },
    { |_, calls| calls().each{ |block| block.run(obj) } }
  )
}

class ModularInit {
  method init {
    _call_methods_blocks_by(self, /^init_steps/)
    self
  }
}


const Array global_init_steps_sa_base = [
  { ._do_serial([], ._bound_accessor_generator ) }
]

class SeriallyAccessible << ModularInit, SeriallyEquatable {
  has Array init_steps_sa_base = global_init_steps_sa_base
  method _bound_accessor_generator {
    const MN = __METHOD_NAME__
    {
        |field_name, field_rhs|

      process_serial_prop_rhs([MN, :V_bound_block, :V_first_step], field_name, field_rhs, \var Object typename, \var Object default_val, \var Hash custom_blocks)

      (typename ~~ default_val) \
        || die (
          "#{__FILE__}:#{__LINE__}: #{__METHOD_NAME__}: type mismatch when generating default value for '#{field_name}': ",
          "want '#{typename}'; got '#{default_val.class}' ('#{default_val.dump}')"
      )

      die 'class already has raw property named \''+field_name.dump+'\' (did you forget to declare the raw property with \'_'+field_name+'\'?)' if ( self.is_property([MN, :V_bound_block], field_name, default_val) )

      # create the private slot
      # say "#{__METHOD_NAME__}: setting _#{field_name} to '#{default_val.dump}'"
      self{:_ + field_name} = default_val
      # say "#{__METHOD_NAME__}: set _#{field_name}"

      const Block setter_prelude = {
        .is_a(typename) \
          || die(
            "#{__FILE__}:#{__LINE__}: #{__METHOD_NAME__}:  ",
            "type mismatch in generated setter '#{field_name}': want '#{typename}'; got '#{_.class}'  ('#{_.dump}')"
        )
      }


      func acc (self) {
        # say "get field #{field_name}"
        # say "custom_blocks: #{custom_blocks}"
        static var custom_getter = custom_blocks{:get}
        # say "get field #{field_name} (#{typename}) with #{custom_getter}"
        if (custom_getter) { custom_getter.run(self) } else { self{:_ + field_name} }
      }

      func acc (self, new_val) {
        static var custom_setter = custom_blocks{:set}
        setter_prelude.run(new_val)
        # say "set field #{field_name} to #{new_val} (#{typename})"
        if (custom_setter) { custom_setter.run(self, new_val) \\ self } else { self{:_ + field_name} = new_val; self }
      }
      __CLASS__.def_method(field_name, acc)
      # say "declared accessor for #{field_name}"
    }
  }

  method _property_generator {
    define Regex serial_pg_name = /^serial_property_generator([_\w]+)$/
    self.grep_methods( { _ ~~ serial_pg_name } ) \
      .each_kv{
            |name, calls|
          say "createproperty #{name} => calls #{calls}"
          __CLASS__.def_method(
            :serial_properties + (name =~ serial_pg_name)[0],
            func curried (self) { calls().run(self) }
          )
      }
  }
}


class Lockable {
  has Bool _impl_locked = false
  has String _impl_err_write_locked = 'attempt of write to locked '+__CLASS_NAME__+' object!'

  -> lock { self._impl_locked = true }
  -> lock (Bool b) { self._impl_locked = b }
  -> unlock { self._impl_locked = false }
}
