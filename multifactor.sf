#! sidef -WkP8
# /usr/bin/env
#`(exit the shell) {
  eval 'exec sidef -WkP8 $0 ${1+"$@"}'
}

##  MultiFactor, meta build system for Factor core development
##    Copyright Cat Stevens 2018
##  This program is free software: you can redistribute it and/or modify
##    it under the terms of the GNU General Public License as published by
##    the Free Software Foundation, either version 3 of the License, or
##    (at your option) any later version.
##
##    This program is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
##
##    You should have received a copy of the GNU General Public License
##    along with this program.  If not, see <https://www.gnu.org/licenses/>.

include argparse
include shell_words

define Hash SCRIPT = :(
  "version" => "0.3",
  "name" => "multifactor",
  "doc" => "a meta build system for Factor core development",
  "bug" => "github.com/catb0t/multifactor/issues",
  "license" => "GPL v3+"
)

# basic variable definitions for working with Factor
module Factor {
  const String RC_FILE = Dir.home+%f(.factor-rc)

  func find_config (name) {
    const regex = Regex("^! multifactor:#{name} (.*)")
    File(RC_FILE).open_r.lines.each {
      with ( .match(regex)[0] ) { return _ }
    }
    die "Config 'multifactor:#{name}' not found in #{Factor::RC_FILE}"
  }

  const Dir REPO = Dir(find_config("repo"))
  const Regex VERSION_REGEX = /VERSION = ([0-9]+\.[0-9]+)/
  const String VERSION = (
    VERSION_REGEX =~ (
      REPO+%f(GNUmakefile)->open_r.lines.find { |l| l ~~ VERSION_REGEX }
    )
  )[0]
}

class BuiltObj (
  String _id,
  String _git_branch,
  String _git_hash, # git rev-parse HEAD
  String _os_type,
  String _os_name,
  String _arch_name,
  String _word_size,
  String _sum_vm_names,
  String _sum_vm_contents,
  String _sum_image_names,
  String _sum_image_contents,
  String _vm_blob_sum,
  String _image_blob_sum,
  String _vm_base_name = :factor,  # usually "factor"
  String _image_ext = ".image",    # usually ".image"
  Bool   _lk = false               # object locking
) {
  -> lk (Bool l) -> BuiltObj { self._lk = l ; self }
  -> id () -> String { self.id }
  -> id (String id) -> BuiltObj { if (!self._lk) { self._id = id }; self }
  -> git_branch () -> String { self._git_branch }
  -> git_branch (String gb) -> BuiltObj { if (!self._lk) { self._git_branch = gb }; self }
  -> git_hash () -> String { self._git_hash }
  -> git_hash (String hs) -> BuiltObj { if (!self._lk) { self._git_hash = hs }; self }
  -> os_type () -> String { self._os_type }
  -> os_type (String os) -> BuiltObj { if (!self._lk) { self._os_type = os }; self }
  -> os_name () -> String { self._os_name }
  -> os_name (String os) -> BuiltObj { if (!self._lk) { self._os_name = os }; self }
  -> arch_name () -> String { self._arch_name }
  -> arch_name (String an) -> BuiltObj { if (!self._lk) { self._arch_name = an }; self }
  -> word_size () -> String { self._arch_name }
  -> word_size (String ws) -> BuiltObj { if (!self._lk) { self._word_size = ws }; self }
  -> sum_vm_names () -> String {  self._sum_vm_names }
  -> sum_vm_names (String x) -> BuiltObj { if (!self._lk) { self._sum_vm_names = x }; self }
  -> sum_vm_contents () -> String {  self._sum_vm_contents }
  -> sum_vm_contents (String x) -> BuiltObj { if (!self._lk) { self._sum_vm_contents = x }; self }
  -> sum_image_names () -> String {  self._sum_image_names }
  -> sum_image_names (String x) -> BuiltObj { if (!self._lk) { self._sum_image_names = x }; self }
  -> sum_image_contents () -> String {  self._sum_image_contents }
  -> sum_image_contents (String x) -> BuiltObj { if (!self._lk) { self._sum_image_contents = x }; self }
  -> vm_blob_sum () -> String { self._vm_blob_sum }
  -> vm_blob_sum (String x) -> BuiltObj { if (!self._lk) { self._vm_blob_sum = x }; self }
  -> image_blob_sum () -> String {  self._image_blob_sum }
  -> image_blob_sum (String x) -> BuiltObj { if (!self._lk) { self._image_blob_sum = x }; self }
  -> vm_base_name () -> String {  self._vm_base_name }
  -> vm_base_name (String x) -> BuiltObj { if (!self._lk) { self._vm_base_name = x }; self }
  -> image_ext () -> String { self._image_ext }
  -> image_ext (String x) -> BuiltObj { if (!self._lk) { self._image_ext = x }; self }
}

class MultiFactor (
    Hash options,
    Array factor_arguments
    # not using globbed arguments
  ) {

  # actually implement the data model
  class BlobDatabase (disk_name) {

    has disk_file = -> { File( Factor::REPO + self.disk_name ) }

  }
}

func usec { Time.micro*10_000 }
func usec (Number n) { Time.micro*10_000 - n }

func main () {
  var us = usec()
  # say Factor::RC_FILE
  # say Factor::REPO
  # say Factor::VERSION
  # say Dir.cwd
  # say Dir.chdir(Factor::REPO)
  # say Dir.cwd

  var parser = argparse::ArgParse(ARGV) \
    .info(SCRIPT) \
    .option("force", "f", doc: "Force a rebuild in any case") \
    .option("dry-run", "n", doc: "Print configuration; commit no changes") \
    .option("verbose", "V", doc: "Be verbose") \
    .option("trace", "t", doc: "An unreasonable amount of debug tracing") \
    .option("clean", "c", negate: "Always":"Never", doc: "'make clean'") \
    .option("sums", "s",  negate: "Always":"Never", doc: "use checksums") \
    .option("sum-len", "l", param: "len":"12", doc: "Shorten checksums to this length") \
    .option("db", "d", param: "file":".multifactor.db", doc: "Use this database instead") \
    .use_option_terminator("Further arguments are given to Factor") \
    # .use_stdin_file_arg \
    # .use_arg_list_terminator \
    # .ignore_unknowns \
    .arg("arg...", doc: "Arguments to the final Factor VM")


  var (opts, args) = parser.go...
  say "#{opts} #{args}"

  # say BuildSh::cc()
  # say BuildSh::cxx()
  # say BuildSh::arch_name()
  # say BuildSh::word_size()
  say BuildSh::generate_make_targets()

  say FactorBash::sum_git_names_matching(/\.s(?:m|f)/)
  say FactorBash::sum_git_contents_matching(/\.s(?:m|f)/)

  say "\tÎ”#{usec(us)}"
}

if (__FILE__ == __MAIN__) {
  main()
}
