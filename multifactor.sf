#! sidef -WkP8
# /usr/bin/env
#`(exit the shell) {
  eval 'exec sidef -WkP8 $0 ${1+"$@"}'
}

##  MultiFactor, meta build system for Factor core development
##    Copyright Cat Stevens 2018
##  This program is free software: you can redistribute it and/or modify
##    it under the terms of the GNU General Public License as published by
##    the Free Software Foundation, either version 3 of the License, or
##    (at your option) any later version.
##
##    This program is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
##
##    You should have received a copy of the GNU General Public License
##    along with this program.  If not, see <https://www.gnu.org/licenses/>.

include argparse
include shell_words

define Hash SCRIPT = :(
  "version" => "0.3",
  "name" => "multifactor",
  "doc" => "a meta build system for Factor core development",
  "bug" => "github.com/catb0t/multifactor/issues",
  "license" => "GPL v3+"
)

# basic variable definitions for working with Factor
module Factor {
  const String RC_FILE = Dir.home+%f(.factor-rc)

  func find_config (name) {
    const regex = Regex("^! multifactor:#{name} (.*)")
    File(RC_FILE).open_r.lines.each {
      with ( .match(regex)[0] ) { return _ }
    }
    die "Config 'multifactor:#{name}' not found in #{Factor::RC_FILE}"
  }

  const Dir REPO = Dir(find_config("repo"))
  const Regex VERSION_REGEX = /VERSION = ([0-9]+\.[0-9]+)/
  const String VERSION = (
    VERSION_REGEX =~ (
      REPO+%f(GNUmakefile)->open_r.lines.find { |l| l ~~ VERSION_REGEX }
    )
  )[0]
}

class MultiFactor (
    Hash options,
    Array factor_arguments
    # not using globbed arguments
  ) {

  # actually implement the data model
  class BlobDatabase (disk_name) {

    has disk_file = -> { File( Factor::REPO + self.disk_name ) }

  }
}

func usec { Time.micro*10_000 }
func usec (Number n) { Time.micro*10_000 - n }

func main () {
  var us = usec()
  # say Factor::RC_FILE
  # say Factor::REPO
  # say Factor::VERSION
  # say Dir.cwd
  # say Dir.chdir(Factor::REPO)
  # say Dir.cwd

  var parser = argparse::ArgParse(ARGV) \
    .info(SCRIPT) \
    .option("force", "f", doc: "Force a rebuild in any case") \
    .option("dry-run", "n", doc: "Print configuration; commit no changes") \
    .option("verbose", "V", doc: "Be verbose") \
    .option("trace", "t", doc: "An unreasonable amount of debug tracing") \
    .option("clean", "c", negate: "Always":"Never", doc: "'make clean'") \
    .option("sums", "s",  negate: "Always":"Never", doc: "use checksums") \
    .option("sum-len", "l", param: "len":"12", doc: "Shorten checksums to this length") \
    .option("db", "d", param: "file":".multifactor.db", doc: "Use this database instead") \
    .use_option_terminator("Further arguments are given to Factor") \
    # .use_stdin_file_arg \
    # .use_arg_list_terminator \
    # .ignore_unknowns \
    .arg("arg...", doc: "Arguments to the final Factor VM")


  var (opts, args) = parser.go...
  say "#{opts} #{args}"

  # say BuildSh::cc()
  # say BuildSh::cxx()
  # say BuildSh::arch_name()
  # say BuildSh::word_size()
  say BuildSh::generate_make_targets()

  say FactorBash::sum_git_names_matching(/\.s(?:m|f)/)
  say FactorBash::sum_git_contents_matching(/\.s(?:m|f)/)

  say "\tÎ”#{usec(us)}"
}

if (__FILE__ == __MAIN__) {
  main()
}
