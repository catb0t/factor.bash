#! sidef -WkP8
# /usr/bin/env
#`(exit the shell) {
  eval 'exec sidef -WkP8 $0 ${1+"$@"}'
}

##  MultiFactor, meta build system for Factor core development
##    Copyright Cat Stevens 2018
##  This program is free software: you can redistribute it and/or modify
##    it under the terms of the GNU General Public License as published by
##    the Free Software Foundation, either version 3 of the License, or
##    (at your option) any later version.
##
##    This program is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
##
##    You should have received a copy of the GNU General Public License
##    along with this program.  If not, see <https://www.gnu.org/licenses/>.

include argparse

define Hash SCRIPT = :(
  "version" => "0.3",
  "name" => "multifactor",
  "doc" => "a meta build system for Factor core development",
  "bug" => "github.com/catb0t/multifactor/issues",
  "license" => "GPL v3+"
)

# basic variable definitions for working with Factor
module Factor {
  const String RC_FILE = Dir.home+File(".factor-rc")

  func find_config (name) {
    const regex = Regex("^! multifactor:#{name} (.*)")
    File(RC_FILE).open_r.lines.each {
      with ( .match(regex)[0] ) { return _ }
    }
    die "Config 'multifactor:#{name}' not found in #{Factor::RC_FILE}"
  }

  const Dir REPO = Dir(find_config("repo"))
  const Regex VERSION_REGEX = /VERSION = ([0-9]+\.[0-9]+)/
  const String VERSION = (
    VERSION_REGEX =~ (
      REPO+%f(GNUmakefile)->open_r.lines.find { |l| l ~~ VERSION_REGEX }
    )
  )[0]
}

module Command {
  func ql (Array args) -> String {
    args.map{ "'#{_}' "}.join
  }
  func make (*args) {
    `make -j #{ql(args)}`
  }
  func rm (Array args, Array opts = []) {
    # say args.dump
    # say opts.dump
    `rm #{ql(opts)} #{ql(args)}`
  }
  func mv (from, to, Array opts = []) {
    `cp #{ql(opts)} '#{from}' '#{to}'`
  }
  func cp (from, to, Array opts = []) {
    `cp #{ql(opts)} '#{from}' '#{to}'`
  }
}

# `build.sh` bash functions
# THEIR utilities, re-implemented in Sidef
module BuildSh {
  include Command
  -> downloader{
    'LWP::UserAgent'.require.new(show_progress => 1)
  }
  func make_http_request (url) {
    var resp = BuildSh::downloader().get(url)

    if (resp.is_success) {
      resp.decoded_content
    }
    false
  }
  -> find_programs (String kind, Array ps) is cached -> Array {
    say "Look for '#{kind}': #{ps.join(', ')}..."
    # could probably optimise this by just returning the first match
    const results = ps.map{
        |p|
      p.quotemeta!
      var s = `which #{p}`.chomp
      if (Number($?) == 0) { say "\tfound #{p}: #{s}"; s }
    }.flatten.grep{_}

    (results.is_empty ? die "no #{kind}" : results)
  }
  # TODO: not *required*
  -> check_cc_version (String name) is cached -> Bool {
    Bool(name)
    ...
  }
  -> cc () is cached {
    BuildSh::find_programs(:cc, %w(clang gcc cc)).first
  }
  -> cxx () is cached {
    BuildSh::find_programs(:cxx, ['clang++', 'g++', 'c++', 'cpp']).first
  }
  # NOTE: using Sys.osname in place of uname until it causes a problem
  -> arch_name () is cached {
    if ([:ppc64, "Power Macintosh"].contains(`uname -m`.chomp)) {
      :ppc
    } else {
      :x86
    }
  }
  -> c_word_size () is cached {
    const File ws_name = %f(factor_word_size)
    `echo '#include <stdio.h>
int main(){printf(\"%ld\",(long)(8*sizeof(void*)));}' | #{BuildSh::cc()} -xc -o#{ws_name} -`

    die "couldn't call the C compiler" \
      if (Number($?) != 0)

    const ws = `./#{ws_name}`
    if (Number($?) != 0) {
      Command::rm([ws_name])
      die "couldn\'t run the word size program"
    }
    Command::rm([ws_name])
    ws
  }
  -> intel_macosx_word_size () is cached {
    const s = BuildSh::find_programs(:sysctl, ["sysctl"]).first
    `#{s} machdep.cpu.extfeatures | grep EM64T >/dev/null`
    (Number($?)==0 ? "64" : "32")
  }
  -> word_size () is cached {
    if (Sys.osname~~"macos" && BuildSh::arch_name()~~:x86) {
      BuildSh::intel_macosx_word_size()
    } else {
      BuildSh::c_word_size()
    }
  }

  # format: OS-ARCH.BITS
  -> generate_make_targets () is cached {
    const (
      os = Sys.osname,
      an = BuildSh::arch_name(),
      ws = BuildSh::word_size()
    )
    Hash(
      :make_image => "#{os}-#{an}.#{ws}",            # MAKE_IMAGE_TARGET
      :make_binary => "#{os}-#{an}-#{ws}",           # MAKE_TARGET
      :boot_image => "boot.#{os}-#{an}.#{ws}.image", # BOOT_IMAGE
    )
  }

  -> current_git_branch () is cached {
    const branch = `git rev-parse --abbrev-ref HEAD`
    (Number($?)==0 ? branch : :master)
  }

}

# factor.bash bash functions
# OUR utilities, re-implemented in Sidef
module FactorBash {
}

# words to checksum directory file contents and file names goes here
module GlobSum { }

class MultiFactor (
    Hash options,
    Array factor_arguments
    # not using globbed arguments
  ) {

  # actually implement the data model
  class BlobDatabase (disk_name) {

    has disk_file = -> { File( Factor::REPO + self.disk_name ) }

  }
}

func usec { Time.micro*10_000 }
func usec (Number n) { Time.micro*10_000 - n }

func main () {
  var us = usec()
  say Factor::RC_FILE
  say Factor::REPO
  say Factor::VERSION
  say Dir.cwd
  # say Dir.chdir(Factor::REPO)
  # say Dir.cwd

  var parser = argparse::ArgParse(ARGV) \
    .info(SCRIPT) \
    .option("force", "f", doc: "Force a rebuild in any case") \
    .option("dry-run", "n", doc: "Print configuration; commit no changes") \
    .option("clean", "c", negate: "Always":"Never", doc: "'make clean'") \
    .option("sums", "s",  negate: "Always":"Never", doc: "use checksums") \
    .option("db", "d", param: "file":".multifactor.db", doc: "Use this database instead") \
    .use_option_terminator("Further arguments are given to Factor") \
    # .use_stdin_file_arg \
    # .use_arg_list_terminator \
    # .ignore_unknowns \
    .arg("arg...", doc: "Arguments to the final Factor VM")


  var (opts, args) = parser.go...
  say "#{opts} #{args}"

  say BuildSh::cc()
  say BuildSh::cxx()
  say BuildSh::arch_name()
  say BuildSh::word_size()
  say BuildSh::generate_make_targets()

  say "\tÎ”#{usec(us)}"
}

if (__FILE__ == __MAIN__) {
  main()
}
