# this exists so we can check the blob sums without having to use scoped assignment
# -> do_blob_sums (String type, File blob) {
#   const sum = self._blob_file_contents_sum(blob, match_bo.blob_sums.algo)
#   const property = type+:_blob_sum
#   Hash(
#     (property) => sum,
#     (type+:_matches) => ( sum == match_bo.method(property)() )
#   ).cleave(
#     { say "#{property}: #{match_bo.method(property)()} #{_}" if (self.debug) },
#     { current_blob_sums.merge!(_) }
#   ).last
# }
# do_blob_sums(:vm, matching_vm_name)
# do_blob_sums(:image, matching_image_name)


# new_recompiled.merge!(
#   if (! [current_blob_sums{:vm_matches, :image_matches}].all{ _ } ) {
#     # due to different compiler versions
#     self.trc(__LINE__, MN, 'blob sums mismatch!')
#     # ???
#     Hash(
#       :vm => new_recompiled{:vm} || if (! current_blob_sums{:vm_matches}) {
#         self.trc(__LINE__, MN, 'recompiling VM!')
#         self.compile_vm_lib(matching_vm_name) -> cleave(
#           { do_blob_sums(:vm, matching_vm_name) },
#           { _ }
#         ).last
#       },
#       :image => new_recompiled{:image} || if (! current_blob_sums{:image_matches}) {
#         self.trc(__LINE__, MN, 'recompiling image!')
#         self.compile_image(matching_vm_name, matching_image_name) -> cleave(
#           { do_blob_sums(:image, matching_image_name) },
#           { _ }
#         ).last
#       }
#     )
#   } else { Hash() }
# )
# blob sums have been implicitly re-checked
