#! ruby

##  CacheDB, a transactional minimalism-oriented JSON "data base" implementation
##    Copyright Cat Stevens 2018
##  This program is free software: you can redistribute it and/or modify
##    it under the terms of the GNU General Public License as published by
##    the Free Software Foundation, either version 3 of the License, or
##    (at your option) any later version.
##
##    This program is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
##
##    You should have received a copy of the GNU General Public License
##    along with this program.  If not, see <https://www.gnu.org/licenses/>.

include sidefext::construct
include sidefext::iterable

include lib::guardio
include lib::feature
include lib::withdirectory
include lib::ABCs

import sidefext::iterable::ImmutableHash

module CacheDBIO {
  import sidefext::iterable::ImmutableHash

  include Atomic

  # look for the database file
  func _read_disk_db (File name, lib::ABCs::Serializable element_type) is cached -> ImmutableHash {

    # look for the database file
    # if it doesn't exist, stop
    # otherwise, open it
    if ( Atomic::aread(name) ) {
        |contents|
      ImmutableHash( Feature::JSON.decode(contents) ) \
        # TODO: fixup this use of unserialize on Hash<Serializable>
        .map_kv{
            |_, v|
          ( (_) =>
            ( sidefext::construct::maybe_init( element_type ) ) -> unserialize(v) )
        }
    } else {
      # if it's empty, get a new one
      ImmutableHash()
    }

  }

  func _write_disk_db (File name, ImmutableHash new_data) {
    # look for the database file
    # if it doesn't exist, stop
    # otherwise, open it
    # fixup this use of .serialize on a Hash<Serializable>
    Atomic::awrite( name, Feature::JSON.new.pretty.encode( new_data.map_kv{ |_, v| ((_) => v.serialize) } ) )
  }
}

module DBTransform {
  import sidefext::iterable::ImmutableHash

  define Array ACTIONS = [:insert, :insert_by, :change, :change_by, :delete, :delete_by, ]

  subset Action < String { ACTIONS.contains(_) }

  struct Transformation {
    action < Action,
    String key,
    Block action_by,
    String uuid,
    Time generated_at
  }

  # Good afternoon, gentleman, I'm a C compiler
  func new_transformation ( a < Action, Str k, Block b ) -> Transformation {
    Transformation(a, k, b, GuardIO::make_uuid(len: 10), Time() )
  }

  func apply_transformation ( ImmutableHash data, Transformation tf ) -> ImmutableHash {
    ImmutableHash( given (tf.action) {
      when (:delete) { data - tf.key }
      when (:delete_by) { data.grep_kv{ |k, v| !tf.action_by.run(k, v) } }
      default { die "Unimplemented Transformation action: #{_}; fix your code or implement it"}
    } )
  }

  func apply_transformations ( ImmutableHash data, Set tfs ) -> ImmutableHash {
    # tfs.values.reduce( { |data, tf| apply_transformation(data, tf) }, data )
    # TODO: Set.reduce
    tfs.values.reduce( apply_transformation, data )
  }
}

define Hash TEMPLATE_SETUP_CACHEDB = :(
  :dir => Dir,
  :filename_base => File,
  :dry_run => Bool,
  :verbose => Bool,
  :trace => Bool,
  :replace_existing => Bool,
  :debug => :( :type => Bool, :default => true ),
  :logger => :( :type => GuardIO::SLog, :deferred => { GuardIO::SLog( is_verbose: .{:verbose}, is_trace: .{:trace} ) } ),
  :element_type => :( :type => lib::ABCs::Serializable, :val_is_typename => true )
)

class CacheDB < lib::withdirectory::CapturedWriter {

  has Set change_sequence = Set()
  has ImmutableHash orig_data = ImmutableHash()
  has GuardIO::SLog log

  has Bool dry_run
  has Dir db_dir
  has File filename_base
  has lib::ABCs::Serializable element_type

  -> db_name () is cached -> File { self.db_dir + self.filename_base }
  # for CapturedWriter
  -> wd () is cached -> Dir { self.db_dir }

  -> data () is cached -> ImmutableHash { self.orig_data }

  method setup (Hash cdb_opts) -> __CLASS__ {
    TEMPLATE_SETUP_CACHEDB.template_transform(cdb_opts).rescope{
      self.log = (*.{:logger})(_)
      self.dry_run = .{:dry_run}

      self.db_dir = .{:dir}
      self.filename_base = .{:filename_base}

      self.element_type = .{:element_type}

      if (.{:replace_existing} && self.db_name.exists) {
        self.log.wrn(__FILE__, __LINE__, __METHOD_NAME__, "!!! removing old DB !!!")
        self.db_name.cleave({ .remove }, { .touch })
      } elsif ( ! self.db_name.exists ) {
        self.db_name.touch
      }
    }

    [:change, :insert, :delete].each{
        |action|
      const ab = (action + :_by)

      func ts (__CLASS__ self, String k, Block b) -> __CLASS__ {
        self.transform( DBTransform::new_transformation(ab, k, b) )
        self
      }

      func generated_action_by (__CLASS__ self, String k, Block b) -> __CLASS__ { ts(self, k, b) }
      func generated_action_by (__CLASS__ self, Object o) -> __CLASS__ {
        (action ~~ /delete/) ? ts(self, o.id, { .== o.id } ) : ts(self, o.id, { o } )
      }

      __CLASS__.def_method( ab, generated_action_by )
      __CLASS__.alias_method( ab, action )
    }

    self.orig_data = self._read_disk_db
    self
  }

  method _write_disk_db {
    static Bool called = false
    if (called) { die "bug found: you can't call #{__METHOD_NAME__} more than once" }
    called = true

    self.log.trc(__FILE__, __LINE__, __METHOD_NAME__, 'writing', self.db_name)

    self.capture_write_disk(
      __METHOD_NAME__,
      { CacheDBIO::_write_disk_db( self.filename_base, DBTransform::apply_transformations( self.orig_data, self.change_sequence ) ) }
    )
  }

  method _read_disk_db () is cached -> ImmutableHash {
    static Bool called = false
    if (called) { die "bug found: you can't call #{__METHOD_NAME__} more than once" }
    called = true
    self.log.trc(__FILE__, __LINE__, __METHOD_NAME__, 'reading', self.filename_base)

    self.with_directory{ CacheDBIO::_read_disk_db(self.filename_base, self.element_type) }
  }

  method destroy (Bool is_exc, Hash _exc_info) {
    self.log.wrn(__FILE__, __LINE__, __METHOD_NAME__, 'shutting down!!!')
    ( is_exc ? self.log.wrn(__FILE__, __LINE__, __METHOD_NAME__, 'not writing disk because of an exception') : self._write_disk_db )
  }

  method transform (DBTransform::Transformation tf) -> __CLASS__ {
    self.change_sequence.append(tf)
    self
  }
  method transform (Set tfs) -> __CLASS__ {
    self.change_sequence.concat(tfs)
    self
  }
}
