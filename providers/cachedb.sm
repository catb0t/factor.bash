#! ruby

##  CacheDB, a transactional minimalism-oriented JSON "data base" implementation
##    Copyright Cat Stevens 2018
##  This program is free software: you can redistribute it and/or modify
##    it under the terms of the GNU General Public License as published by
##    the Free Software Foundation, either version 3 of the License, or
##    (at your option) any later version.
##
##    This program is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
##
##    You should have received a copy of the GNU General Public License
##    along with this program.  If not, see <https://www.gnu.org/licenses/>.

include sidefext::construct

include lib::guardio
include lib::withdirectory
include lib::ABCs

module CacheDBIO {
  include Atomic
  const JSON = "JSON::XS".require

  # look for the database file
  func _read_disk_db (File name, lib::ABCs::Serializable element_type) is cached -> Hash {

    # look for the database file
    # if it doesn't exist, stop
    # otherwise, open it
    if ( Atomic::aread(name) ) {
        |contents|
      JSON \
        .new \
        .decode(contents) \
        # fixup this use of unserialize on Hash<Serializable>
        .map_kv{
            |_, v|
          ((_) =>
            *(sidefext::construct::maybe_init( element_type() ).ref) -> unserialize(v)
          )
        }
    } else {
      # if it's empty, get a new one
      Hash()
    }

  }

  func _write_disk_db (File name, Hash new_data) {
    # look for the database file
    # if it doesn't exist, stop
    # otherwise, open it
    # fixup this use of .serialize on a Hash<Serializable>
    Atomic::awrite( name, JSON.new.pretty.encode( new_data.map_kv{ |_, v| ((_) => v.serialize) } ) )
  }
}

module DBTransform {
  define Array ACTIONS = [:insert, :insert_by, :change, :change_by, :delete, :delete_by, ]

  subset Action < String { ACTIONS.contains(_) }

  struct Transformation {
    action < Action,
    String key,
    Block action_by,
    String uuid,
    Time generated_at
  }

  # Good afternoon, gentleman, I'm a C compiler
  func new_transformation ( a < Action, Str k, Block b ) -> Transformation {
    Transformation(a, k, b, GuardIO::make_uuid(len: 10), Time() )
  }

  func apply_transformation ( Hash data, Transformation tf ) -> Hash {
    ...
    tf
    data.dclone
  }
}

define Hash TEMPLATE_SETUP_CACHEDB = :(
  :dir => Dir,
  :filename_base => File,
  :dry_run => Bool,
  :verbose => Bool,
  :replace_existing => Bool,
  :debug => :( :type => Bool, :default => true ),
  :logger => :( :type => GuardIO::SLog, :deferred => { GuardIO::SLog( is_verbose: .{:verbose} ) } ),
  :element_type => :( :type => lib::ABCs::Serializable, :val_is_typename => true )
)

class CacheDB < lib::withdirectory::CapturedWriter {

  has Set change_sequence = Set()
  has Hash orig_data = :()
  has GuardIO::SLog log

  has Bool dry_run
  has Dir db_dir
  has File filename_base
  has lib::ABCs::Serializable element_type

  -> db_name { self.db_dir + self.filename_base }
  # for CapturedWriter
  -> wd { self.db_dir }

  -> data { self.orig_data }

  method setup (Hash cdb_opts) -> __CLASS__ {
    TEMPLATE_SETUP_CACHEDB.template_transform(cdb_opts).rescope{
      self.log = (*.{:logger})(_)
      self.dry_run = .{:dry_run}

      self.db_dir = .{:dir}
      self.filename_base = .{:filename_base}

      self.element_type = .{:element_type}

      if (.{:replace_existing} && self.db_name.exists) {
        self.log.wrn(__FILE__, __LINE__, __METHOD_NAME__, "!!! removing old DB !!!")
        self.db_name.cleave({ .remove }, { .touch })
      } elsif ( ! self.db_name.exists ) {
        self.db_name.touch
      }
    }

    self.orig_data = self._read_disk_db
    self
  }

  method _write_disk_db {
    static Bool called = false
    if (called) { die "bug found: you can't call #{__METHOD_NAME__} more than once" }
    called = true

    self.log.trc(__FILE__, __LINE__, __METHOD_NAME__, 'writing', self.db_name)

    self.capture_write_disk(
      __METHOD_NAME__,
      {
        CacheDBIO::_write_disk_db(
          self.filename_base,
          # TODO: Set.reduce
          self.change_sequence.values.reduce(
            { |data, tf| DBTransform::apply_transformation(data, tf) },
            self.orig_data
          )
        )
      }
    )
  }

  method _read_disk_db () is cached -> Hash {
    static Bool called = false
    if (called) { die "bug found: you can't call #{__METHOD_NAME__} more than once" }
    called = true
    self.log.trc(__FILE__, __LINE__, __METHOD_NAME__, 'reading', self.filename_base)

    self.with_directory{ CacheDBIO::_read_disk_db(self.filename_base, self.element_type) }
  }

  method destroy {
    self.log.wrn(__FILE__, __LINE__, __METHOD_NAME__, 'shutting down!!!')
    self._write_disk_db
  }

  method transform (DBTransform::Transformation tf) {
    self.change_sequence.append(tf)
    self
  }
  method transform ( Array tfs ) {
    self.change_sequence.append(tfs...)
    self
  }

  method change {}
  method insert {}
  method delete {}
}
