#! ruby
include lib::feature
include lib::guardio
include lib::shell_words
include lib::withdirectory
import lib::shell_words::BuildSh

include providers::builtobj

module FactorBashStateless {
  -> _test_candidate_boot_image (builtobj::BuiltObj bo, File c) {
    c.exists && (bo.blob_sums.boot == lib::shell_words::BuildSh.blob_file_contents_sum(c, bo.blob_sums.algo) )
  }

  -> _choose_boot_image (builtobj::BuiltObj bo_target, File boot_image_file) {
    # Array<Pair<Block -> Bool, File>>
    [
      (
        { FactorBashStateless::_test_candidate_boot_image(bo_target, bo_target.boot_fullname) } \
          ¦ { bo_target.boot_fullname }
      ),
      (
        { FactorBashStateless::_test_candidate_boot_image(bo_target, boot_image_file) \
            || lib::shell_words::BuildSh.update_boot_image
        } ¦ { boot_image_file }
      ),
      (
        {
          bo_target.stored_boot_image.cleave(
            { .data.len },
            { .data.base64_decode.method( .algo ) },
            { .sum },
            { GuardIO::write_binary_b64( bo_target.boot_fullname, .data ) }
          ).cleave(
            { .first && .last },
            { [ .[1, 2] ]«==» },
          ).all
        } ¦ { bo_target.boot_fullname }
      ),
      (
        { "give up" } ¦ { die "[FATAL] #{__FUNC_NAME__}: can't find or download boot image\n\tno boot image, can't compile (sorry!)" }
      )
    ].find{ .first.run }.cleave{ .second.run }.last.rescope{
      say "#{__FUNC_NAME__}: !!! Chose #{_}"
      _
    }
  }
}

func _spoof (String m) -> Bool {
  with ( Feature::ANSIColor ) {
    say( .color('bold bright_green'), "[SPOOF] faking #{m}", .color(:reset) );
  }
  true
}

define DIR_REGEXES = Hash(
  :core => /^core\//,
  :basis => /^basis\//,
  :vm => /^vm\//
)

class FactorBash (Dir wd, String sum_src_algo, Bool basis_dev, Bool subcommand_output = false, Bool spoof_build = false) < lib::withdirectory::WithDirectory { # < CapturedWriter??


  # TODO: compare egrep with PCRE to figure out which files are being matched differently
  -> git_files_matching (Dir d) is cached -> Array {
    const Array files = `git ls-files`.lines.grep{ _ ~~ DIR_REGEXES{d} }
    files || die "[FATAL] #{__METHOD_NAME__}: no files matched #{DIR_REGEXES{d}} in #{Dir.cwd}"
    # say "git listing #{files.len} files: #{d}"
    files
  }

  # aka hash_directory_filenames
  -> sum_git_names_matching (Dir d, Str algo) is cached -> String {
    die "#{__METHOD_NAME__}: empty 'algo'! dir: #{d}" if (algo.is_empty)
    # allow utf-8 with SHA
    self.git_files_matching(d).join(10.chr) |> :encode_utf8 |> algo
  }

  # aka hash_directory_contents
  -> sum_git_contents_matching (Dir d, Str algo) is cached -> String {
    die "#{__METHOD_NAME__}: empty 'algo'! dir: #{d}" if (algo.is_empty)
    self.git_files_matching(d).map{
      File(_) |> :open_r |> :slurp |> :encode_utf8
    }.join("\n") |> algo
  }

  -> src_sums () is cached -> builtobj::SrcSums {
    -> single_dirsum (String dir, Bool skip = false) is cached -> NamedParam {
      dir ⫶ builtobj::DirSum(
        algo: self.sum_src_algo,
        names: (skip ? '' : self.sum_git_names_matching(Dir(dir), self.sum_src_algo)),
        contents: (skip ? '' : self.sum_git_contents_matching(Dir(dir), self.sum_src_algo))
      )
    }

    self.with_directory{
      builtobj::SrcSums(
        # .push( single_dirsum(:basis, self.basis_dev) )...,
        Set(:vm, :core, :basis).map{
          single_dirsum(_, .== :basis && self.basis_dev)
        }...,
        basis_ignored: self.basis_dev
      )
    }
  }

  -> delegate (String name) is cached {
    const MN = __METHOD_NAME__
    # say "#{name} #{[@|args]}"
    if ( self.has_public_concrete_method([MN, :V_self_method, :V_ + name], name) ) {
      self.method( name )()
    } elsif ( lib::shell_words::BuildSh.has_public_concrete_method([MN, :V_buildsh_method, :V_ + name], name) ) {
      # with ( Feature::ANSIColor ) {
      #   say( .color('bold blue'), "[CALL] #{__METHOD_NAME__}: BuildSh staticmethod #{name} FIXME???", .RESET )
      # }
      self.with_directory{ lib::shell_words::BuildSh.method(name)(BuildSh) }
    } else {
      nil
    }
  }

  -> say_src_sums {
    say "#{self.src_sums.vm.names}  vm names"
    say "#{self.src_sums.vm.contents}  vm contents"
    say "#{self.src_sums.core.names}  core names"
    say "#{self.src_sums.core.contents}  core contents"
    say "#{self.src_sums.basis.names}  basis names"
    say "#{self.src_sums.basis.contents}  basis contents"
  }

  -> say_env_info {
    const l = lib::shell_words::BuildSh.platform_lib_name
    const c = lib::shell_words::BuildSh.cc
    const xx = lib::shell_words::BuildSh.cxx
    say()
    say "cc=#{c}"
    say "cxx=#{xx}"
    say "os_name=#{self.delegate(:os_name)}"
    say "os_type=#{self.delegate(:os_type)}"
    say "arch_name=#{self.delegate(:arch_name)}"
    say "word_size=#{self.delegate(:word_size)}"
    say()
    say "is_git=#{self.delegate(:is_git)}"
    say "git_branch=#{self.delegate(:git_branch)}"
    say "git_hash=#{self.delegate(:git_hash)}"
    say()
    say "platform_vm_ext=factor#{lib::shell_words::BuildSh.platform_vm_ext}"
    say "platform_lib_name=#{l.first}factor#{l.second}"
    say "platform_makefile=#{self.delegate(:platform_makefile)}"
    say()
    say "factor_version=#{self.delegate(:factor_version)}"
    say "feature_reproducible=#{self.delegate(:feature_reproducible)}"
  }

  -> build_factor (builtobj::BuiltObj bo_target, Bool clean_would_race) -> Bool {
    ( self.spoof_build ? _spoof(__METHOD_NAME__) : self.with_directory{
      bo_target.cleave(
        { .lock },
        { Combi::first( lib::shell_words::BuildSh.make_clean_factor(_, no_clean: clean_would_race, output: self.subcommand_output) ) },
        { .vm_fullname.exists }, { .lib_fullname.exists }, { .unlock }
      ).all
    } )
  }

  -> _refresh_image (builtobj::BuiltObj bo_target) -> Bool {
    ( self.spoof_build ? _spoof(__METHOD_NAME__) : self.with_directory{
      Combi::first( Command::spawn_se(
        './' + bo_target.vm_fullname, '-no-user-init', "-i='#{bo_target.image_fullname}'",
        "-e='USING: vocabs.loader vocabs.refresh system memory ; refresh-all save 0 exit'",
        output: self.subcommand_output
      ) )
    } )
  }
  -> _make_boot_image (builtobj::BuiltObj bo_target, Str target, File want_name) -> Bool {
    ( self.spoof_build ? _spoof(__METHOD_NAME__) : self.with_directory{
      ( Combi::first( Command::spawn_se(
        './' + bo_target.vm_fullname, '-no-user-init', "-i='#{bo_target.image_fullname}'",
        "-e='USING: system bootstrap.image memory ; \"#{target}\" make-image image-path save-image 0 exit'",
        output: self.subcommand_output
      ) ) && lib::shell_words::BuildSh.generate_make_targets(){:boot_image}.move(want_name) )
    } )
  }

  -> build_image (builtobj::BuiltObj bo_target) -> Bool {
    ( self.spoof_build ? _spoof(__METHOD_NAME__) : self.with_directory{
      define String lead = "==== "
      bo_target.lock

      const make_targets = lib::shell_words::BuildSh.generate_make_targets
      const File default_boot_image_file = make_targets{:boot_image}

      # try the local one with our id
      const using_boot_image = FactorBashStateless::_choose_boot_image(bo_target, default_boot_image_file)
      # this side-effecting code will be deferred until used, except that isn't acutally what we want
      using_boot_image

      -> run_boot_image -> Bool {
        Combi::first( Command::spawn_se("echo \"USE: system 255 (exit)\"", '|', './' + bo_target.vm_fullname, '-no-user-init' "-i='#{using_boot_image}'", output: self.subcommand_output) )
      }
      var count_refresh = 1
      # NOTE: STEP 1: run from boot image
      say "#{lead}Compiling from boot image, pass \##{count_refresh}"
      if (! run_boot_image() ) {
        say "[WARN]\t#{__METHOD_NAME__}: First pass not OK, trying again"

        const updated = lib::shell_words::BuildSh.update_boot_image

        die "[FATAL] #{__METHOD_NAME__}: Failed to update, can't recover" \
          if (!updated)

        die "[FATAL] #{__METHOD_NAME__}: Still can't run from the new boot image, something is deeply wrong" \
          if ( updated && !run_boot_image() )

        say "#{lead}Second pass OK"
      } else {
        say "#{lead}First pass OK"
      }

      const Str boot_image_base = make_targets{:boot_image_base}
      # NOTE: STEP 2: refresh-all from newly compiled image
      var Bool image_fails_refresh = !self._refresh_image(bo_target)
      # NOTE: STEP 3: re-bootstrap and refresh until it doesn't break
      while (image_fails_refresh && (count_refresh < 25) ) {
        say "#{lead}Boot image refresh \##{count_refresh} failed! bootstrapping again..."

        # NOTE: STEP 3a: new boot image
        if (! self._make_boot_image(bo_target, boot_image_base, using_boot_image) ) {
          die "[FATAL] #{__METHOD_NAME__}: failed to make a boot image (refresh \##{count_refresh}): #{$!}"
        }

        # NOTE: STEP 3b: repeat STEP 1
        run_boot_image()
        # NOTE: STEP 3b: repeat STEP 2
        image_fails_refresh = !self._refresh_image(bo_target)
        count_refresh++
      }
      die "[FATAL] Can't possibly compile a working image" if (image_fails_refresh)
      # NOTE: STEP 4: build a final boot image with the working factor.image
      const retval = using_boot_image.cleave(
        { self._make_boot_image(bo_target, boot_image_base, _) },
        { _ == bo_target.boot_fullname ? true : .copy(bo_target.boot_fullname) }
      ).all

      bo_target.unlock

      # don't delete the boot image?
      # mv boot_image my_boot_image_name
      say "#{lead}Finished image compilation after #{count_refresh} refresh#{count_refresh > 1 ? 'es' : '' }"

      retval
    } )
  }
}
