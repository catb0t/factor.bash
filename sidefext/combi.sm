#! ruby

##  Combi, Factor/Scheme-style higher-order combinators to patch missing
##    functionality in Sidef

##    Copyright Cat Stevens 2018
##  This program is free software: you can redistribute it and/or modify
##    it under the terms of the GNU General Public License as published by
##    the Free Software Foundation, either version 3 of the License, or
##    (at your option) any later version.
##
##    This program is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
##
##    You should have received a copy of the GNU General Public License
##    along with this program.  If not, see <https://www.gnu.org/licenses/>.

module Combi {

  func ifte (obj, Block cond, Block then, Block els) {
    cond(obj) ? then(obj) : els(obj)
  }
  # travelling in a fighter Combi(nators)
  # similar to with, but allows more arguments and doesn't care about definedness
  func rescope (*args) {
    # say "\trescope args: #{args.dump}"
    func _bind_rs (Block b) {
      b.run(@|args)
    }
  }

  func rescope_n (Num n, *args) {
    func _bind_rsn (Block b) {
      b.run( args[0..^n], args.last(args.len - n) )
    }
  }

  # return only the top of the stack
  -> first (*a) { a.last }
  -> second (*a) { a.last(2).first }

  -> rescope_first (*a) { Combi::rescope_n(1, @|a) }
  -> drop (*a) { Combi::rescope( a[1..a.len-1] ) } # drops from the right (top of the stack)
  -> nip (*a) { Combi::rescope( a[0..a.len-2] ) }  # from the left

  -> drop_n (Number n, *a) { Combi::rescope( a[n..a.len-1] ) }
  -> nip_n  (Number n, *a) { Combi::rescope( a[0 .. a.len-(n + 1) ] ) }

  # TODO: ways to make lists from iteration without Array....

  func cleave (*args) {
    func _bind_cleave (*b) {
      b.map{ .run(@|args) }
    }
  }

  func combinate (*blocks) {
    func _combinate_args (*args) {
      func _r_combinate (last_res, Num i) {
        __FUNC__( blocks[i].run(last_res), i )
      }(blocks[0].run(args), 1)
    }
  }

  const Block _bind_apply_block = func (args, Bool ffork) -> Block {
    func _apply_block (*blocks) -> Array {
      const method_name = (ffork ? :ffork : :run)
      const args_padding = ([ nil ] * blocks.len-args.len)
      const blocks_padding = ([ { |*_| (@|_) } ] * args.len-blocks.len)

      # rescope could be used here, but isn't necessary, not even for readability
      with (
        [args + args_padding, blocks + blocks_padding] \
          .zip.map{ _[1] |> ( method_name, _[0] ) }
      ) {
        del args
        (ffork ? .map{ .wait } : _)
      }
    }
  }

  func applyc   (Bool ffork, *args) -> Block { Combi::_bind_apply_block(args, ffork) }
  func apply_a  (Array args) -> Block { Combi::_bind_apply_block(args, false) }
  func apply    (*args) -> Block { Combi::_bind_apply_block(args, false) }
  func applyf_a (Array args) -> Block { Combi::_bind_apply_block(args, true) }
  func applyf   (*args) -> Block { Combi::_bind_apply_block(args, true) }

  func binop (a, b) -> Block {
    # say "a/b: '#{a}' '#{b}'"
    func _op (op) -> Object {
      given (op) {
        when (Block) { continue }
        when (String) { op.run(a, b) }
        when (LazyMethod) { continue }
        default { op(a, b) }
      }
    }
  }

  func _binop_pair_fewer_wrap (Array _args, Array ops) {
    func _recur_binop_pair_fewer_wrap (Array args, Num index) {
      !args ? [] : [
        Combi::binop( args[0, 1] )( ops[ index % ops.len ] ),
        @|__FUNC__( args.last(args.len - 2), index + 1)
      ]
    }(_args, 0)
  }

  func _bind_recur_binop_pair_n_op (Bool _single) {
    func _recur_binop_pair_n_op (Array args, Array ops) -> Array {
      !args ? [] : [
        Combi::binop( args[0, 1] )( ops[0] ),
        @|__FUNC__( args.last(args.len - 2), _single ? ops : ops.last(ops.len - 1) )
      ]
    }
  }

  func _bind_binop_pairs (Array args) -> Block {
    func _binops (*ops) {
      # make up an argument if there was 1 less than even
      const Array padded_args = args+(args.len.is_odd ? [args.last.new] : [])
      with ( ops.len.is_one || (args.len / ops.len -> int == 2 ) ) {
        del args
        # assert(args.len+args.len.is_odd / ops.len -> eq(2) )
        .? _bind_recur_binop_pair_n_op( ops.len.is_one  )( padded_args, ops )
        :  _binop_pair_fewer_wrap( padded_args, ops )
      }
    }
  }
  func binop_pairs_a (Array args) -> Block { Combi::_bind_binop_pairs(args) }
  func binop_pairs (*args) -> Block { Combi::_bind_binop_pairs(args) }

  struct Finalized {
    Bool success
    String f7r_name

    Array obj_args
    Array f7r_args

    Array success_ret
    Array f7r_ret

    Hash exc_info
  }

  # how to deal with multiple return values, without assigning a local?
  # use rescope_n! or apply, maybe
  func with_finalizer (obj, f7r_name, *final_args) {
    # say "got here"
    func _finalizer (block, *bargs) -> Finalized {

      -> fin (String type, String msg) { obj.method(f7r_name)(:(type => type, msg => msg), @|final_args) }

      const Set params_rest = Set(f7r_name: f7r_name, obj_args: bargs, f7r_args: final_args)

      const finalized = try {
        Finalized(
          success: true,
          success_ret: [block.run(obj, @|bargs)],
          f7r_ret: [],
          exc_info: :(),
          params_rest...
        )
      } catch {
          |type, msg|
        return Finalized(
          success: false,
          f7r_ret: [fin(type, msg)],
          success_ret: [],
          exc_info: :(type => type, msg => msg),
          params_rest...
        )
      }
      finalized.f7r_ret.push([fin(:success, '')])
      finalized
    }
  }

  func with_destructor (o, n, *f) { with_finalizer(o, n, f...) }

  # TODO
  #func with_finalizers (Array specs) -> (Bool, Array) {
  #  func _finalizers (*ba_pairs) {
  #    try {
  #      (true, [specs, ba_pairs].zip.map{ _[1].key.run(_[0], @|.value ) } )
  #    } catch {
  #        |_, msg|
  #      (false, specs.map{ .method( _[1] )( msg, @|_.last(_.len - 2) ) } )
  #    }
  #  }
  #}
  #func with_destructors (s) { Combi::with_finalizers(s) }
}
