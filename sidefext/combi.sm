#! ruby

##  Combi, Factor/Scheme-style higher-order combinators to patch missing
##    functionality in Sidef

##    Copyright Cat Stevens 2018
##  This program is free software: you can redistribute it and/or modify
##    it under the terms of the GNU General Public License as published by
##    the Free Software Foundation, either version 3 of the License, or
##    (at your option) any later version.
##
##    This program is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
##
##    You should have received a copy of the GNU General Public License
##    along with this program.  If not, see <https://www.gnu.org/licenses/>.

module Combi {

  func ifte (obj, Block cond, Block then, Block els) {
    cond(obj) ? then(obj) : els(obj)
  }
  func ifte (Block cond, Block then, Block els) {
    const c = [cond()]
    if ( c.all ) { then(c...) } else { els(c...) }
  }
  # travelling in a fighter Combi(nators)
  # similar to with, but allows more arguments and doesn't care about definedness
  func rescope (*args) {
    # say "\trescope args: #{args.dump}"
    func _bind_rs (Block b) {
      b.run(@|args)
    }
  }

  func rescope_n (Num n, *args) {
    func _bind_rsn (Block b) {
      b.run( args[0..^n], args.slice(n) )
    }
  }

  # return only the top of the stack
  -> first (*a) { a.last }
  -> second (*a) { a.last(2).first }

  -> rescope_first (*a) { Combi::rescope_n(1, @|a) }
  -> drop (*a) { Combi::rescope( a[1..a.len-1] ) } # drops from the right (top of the stack)
  -> nip (*a) { Combi::rescope( a[0..a.len-2] ) }  # from the left

  -> drop_n (Number n, *a) { Combi::rescope( a[n..a.len-1] ) }
  -> nip_n  (Number n, *a) { Combi::rescope( a[0 .. a.len-(n + 1) ] ) }

  # TODO: ways to make lists from iteration without Array....

  func cleave (*args) {
    func _bind_cleave (*b) {
      b.map{ .run(@|args) }
    }
  }

  func combinate (*blocks) -> Block {
    func _combinate_args (*args) {
      func _r_combinate (last_res, Num i) {
        __FUNC__( blocks[i].run(last_res), i )
      }(blocks[0].run(args), 1)
    }
  }

  func curry (Block b) {
    func _curry( *args ) {
      b(@|args)
    }
  }

  const Block _bind_apply_block = func (args, Bool ffork) -> Block {
    func _apply_block (*blocks) -> Array {
      const method_name = (ffork ? :ffork : :run)
      const args_padding = ([ nil ] * blocks.len-args.len)
      const blocks_padding = ([ { |*_| (@|_) } ] * args.len-blocks.len)

      # rescope could be used here, but isn't necessary, not even for readability
      with (
        [args + args_padding, blocks + blocks_padding] \
          .zip.map{ _[1] |> ( method_name, _[0] ) }
      ) {
        del args
        (ffork ? .map{ .wait } : _)
      }
    }
  }

  func applyc   (Bool ffork, *args) -> Block { Combi::_bind_apply_block(args, ffork) }
  func apply_a  (Array args) -> Block { Combi::_bind_apply_block(args, false) }
  func apply    (*args) -> Block { Combi::_bind_apply_block(args, false) }
  func applyf_a (Array args) -> Block { Combi::_bind_apply_block(args, true) }
  func applyf   (*args) -> Block { Combi::_bind_apply_block(args, true) }

  func binop (a, b) -> Block {
    # say "a/b: '#{a}' '#{b}'"
    func _op (op) -> Object {
      given (op) {
        when (Block) { continue }
        when (String) { op.run(a, b) }
        when (LazyMethod) { continue }
        case (.is_typename) { continue }
        default { op(a, b) }
      }
    }
  }

  func _binop_pair_fewer_wrap (Array _args, Array ops) {
    func _recur_binop_pair_fewer_wrap (Array args, Num index) {
      !args ? [] : [
        Combi::binop( args[0, 1] )( ops[ index % ops.len ] ),
        @|__FUNC__( args.slice(2), index + 1)
      ]
    }(_args, 0)
  }

  func _bind_recur_binop_pair_n_op (Bool _single) {
    func _recur_binop_pair_n_op (Array args, Array ops) -> Array {
      !args ? [] : [
        Combi::binop( args[0, 1] )( ops[0] ),
        @|__FUNC__( args.slice(2), _single ? ops : ops.slice(1) )
      ]
    }
  }

  func _bind_binop_pairs (Array args) -> Block {
    func _binops (*ops) {
      # make up an argument if there was 1 less than even
      const Array padded_args = args+(args.len.is_odd ? [args.last.new] : [])
      const cond = { ops.len.is_one || (args.len / ops.len -> int == 2 ) }
      del args
      ifte( cond
        { _bind_recur_binop_pair_n_op( ops.len.is_one )( padded_args, ops ) }
        { _binop_pair_fewer_wrap( padded_args, ops ) }
      )
    }
  }
  func binop_pairs_a (Array args) -> Block { Combi::_bind_binop_pairs(args) }
  func binop_pairs (*args) -> Block { Combi::_bind_binop_pairs(args) }

  struct FinalizerSpec {
    obj,
    Array obj_blocks = [],

    Array shared_f7rs, # always call these
    Array ok_f7rs
    Array exc_f7rs

    Bool exc_only = true
  }

  struct Finalized {
    Bool success

    Array success_ret
    Hash f7r_ret

    FinalizerSpec fs
    Array _obj_blocks

    Hash exc_info
  }

  func with_finalizers (FinalizerSpec fs) -> Block {
    const obj_class = fs.obj.class
    say "\tFinalizer #{fs.dump} registered; calling it on exceptions only: #{fs.exc_only}"
    func _finalizer (*_obj_blocks) -> Finalized {

      const obj_blocks = ifte( { _obj_blocks || fs.obj_blocks }
        { cleave(.[0])( { .is_a(Block) }, { .is_object } ).all ? [ .[0] ] : _ }
        { [ [Block.list_identity] ] }
      )

      const exc_info = :( type => 'The operation completed successfully.', msg => '' ) # '

      -> fin (Bool is_exc) -> Hash {
        with (fs) {
          const caller = { [ fs.obj.method( .[0] )( is_exc, exc_info, @|.slice(1) ) ] }
          :((
            :shared => .shared_f7rs.map(caller),
            :exc => is_exc ? .exc_f7rs.map(caller) : [],
            :ok => (!is_exc && !.exc_only) ? .ok_f7rs.map(caller) : [],
          ))
        }
      }

      const Set params_rest = Set(_obj_blocks: _obj_blocks, fs: fs, exc_info: exc_info
)

      const finalized = try {
        Finalized(
          success: true,
          success_ret: obj_blocks.map{ [ .[0].run( fs.obj, @|.slice(1) ) ] },
          f7r_ret: [],
          params_rest...
        )
      } catch {
          |type, msg|
        say "\tFinalizer #{fs.dump} called because '#{type}'"
        exc_info{:type, :msg} = (type, msg)
        return Finalized(
          success: false,
          f7r_ret: fin(true),
          success_ret: [],
          params_rest...
        )
      }
      if (! fs.exc_only) {
        finalized.f7r_ret = fin(false)
      }
      finalized
    }
  }

  func with_destructors (o, n, *f) -> Block { with_finalizer(o, n, f...) }
}
