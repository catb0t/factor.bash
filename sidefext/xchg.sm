#! ruby
# reliable data export / exchange / interchange for Sidef builtins
#   primarily for JSON
include sidefext::metatype

class Array {
  method values { self }
  method all_eq { self.to_set.to_a == [self[0]] }
}
class Matrix { method values { self.flatten } }
class Pair   { method values { self.to_a } }
# class Set { method lacks (*_) { !self.has(_...) } }

module Explicit {
  define EXPL_TYP = :__XT
  define EXPL_STP = :__XS # homogenous subtypes of iterables
  define EXPL_VAL = :__XV
  define USER_TYPE_MAGIC = 'U!!!'

  func make (type, val, stp = false) -> Hash {
    gather {
      take( EXPL_VAL val )
      take( EXPL_TYP type ) if type
      take( EXPL_STP stp )  if stp
    }.to_h
  }

  func _major_subtype_heuristic (val) {
    # the heuristic is an future optimization
    if (val.respond_to(:len) && val.respond_to(:all)) {
      if ( sidefext::metatype::ITER_TYPES.has(val.ref.lookup_ref.to_type) ) {
        with ( val.values.map{ .ref } ) {
          .all_eq && .[0]
        }
      } # else {}
    } # else?
  }

  # TODO: FUTURE
  # func _major_subtype_heuristic_v2 (val) -> Array {
  #   ...
  #   var subtype = _major_subtype_heuristic(val)
  #   !subtype ? [] : [subtype, _major_subtype_heuristic_v2(val.values)...]
  # }
  # TODO: type coding

  func like_user_pair (Object obj) -> Bool {
    obj.is_a(Pair) && obj[0].ref.is_non_builtin_type && obj[0].is_typename && obj[1].is_a(Hash) && obj[1].is_object
  }
  func like_user_pair (Pair p, String ref_0) -> Bool {
    ref_0.is_non_builtin_type && p[0].is_typename && p[1].is_a(Hash) && p[1].is_object
  }
  func like_user_pair (Object obj, String ref_0) -> Bool {
    obj.is_a(Pair) && ref_0.is_non_builtin_type && obj[0].is_typename && obj[1].is_a(Hash) && obj[1].is_object
  }

  func to (obj, subtype = false, Block user_type_hook = Block.identity) -> Hash {
    if ( ! defined(obj) ) {
      :( EXPL_TYP, :nil )
    } elsif (obj.is_typename) {
      :( EXPL_TYP, :typename, EXPL_VAL, obj.ref.mref )
    } else { # defined

      var (st, curried_to) = with ( _major_subtype_heuristic(obj) ) {
        (_, .? func (o) -> Hash { Explicit::to(o, subtype: _) } : Explicit::to)
      }

      var (user_pair, ref) = if ( obj.is_a(Pair) && like_user_pair(obj, obj[0].ref) && obj[0].ref ) {
          |_|
        (true, USER_TYPE_MAGIC + .mref)
      } else { (false, obj.ref) }

      Explicit::make(
        !subtype && ref,
        given (obj) {
          case ( user_pair )     { .[1].map_kv{ |k, v| ( (k) => curried_to(v) ) } }
          case ( .is_a(Pair) )   { continue }
          case ( .is_a(Set) )    { continue }
          case ( .is_an(Array) ) { .to_a.map{ curried_to(_) } }
          case ( .is_a(Hash) )   { .map_kv{ |k, v| ( (k) => curried_to(v) ) } }
          default                { _ }
        },
        st
      )
    }
  }

  func tag_hash (Hash data, Block user_type_hook = Block.identity) -> Hash {
    data.map_kv{
        |k, v|
      ( (k) => Explicit::to(v, user_type_hook: user_type_hook) )
    }
  }

  const tag     = to
  const hash_to = tag_hash

  var _hash_from

  func from (Hash obj, subtype = false, Block user_type_hook = Block.identity) {
    if (obj{EXPL_TYP} == :nil) {
      nil
    } elsif (obj{EXPL_TYP} == :typename) {
      obj{EXPL_VAL}.lookup_ref.to_type
    } else {
      var curried_from = (defined( obj{EXPL_STP} )
        ? func (Hash _) { Explicit::from(_, subtype: obj{EXPL_STP}) }
        : Explicit::from
      )

      var (user_type, type) = with (subtype || obj{EXPL_TYP}) {
        (.starts_with(USER_TYPE_MAGIC), .=~ Regex("^(?:#{USER_TYPE_MAGIC})?(.*)$") -> caps[0].lookup_ref.to_type)
      } else { die '???' }

      var pre_val = obj{EXPL_VAL}

      # say "obj: #{obj.dump.lines.map{ 9.chr+_ }.join(10.chr)}\n\tref: '#{obj{EXPL_TYP}}' last subtype: #{subtype} type_s: #{type_s} type; #{type} is_user_type: #{is_user_type}\n"

      given ( type ) {
        case ( user_type )    {
          with ( user_type_hook.is_identity ? Pair : user_type_hook ) {
              |ctor|
            ctor( _, Explicit::_hash_from(pre_val) )
          }
        }
        case ( .is_a(Pair) )  { continue }
        case ( .is_a(Set) )   { continue }
        case ( .is_a(Array) ) { type( pre_val.map{ curried_from(_) }... ) }
        case ( .is_a(Hash) )  { type( pre_val.map_kv{ |k, v| ( (k) => curried_from(v) ) }... ) }
        default               { type( pre_val ) }
      }
    }
  }

  func untag_hash (Hash data, Block user_type_hook = Block.identity) -> Hash {
    data.map_kv{
        |k, v|
      ( (k) => from(v, user_type_hook: user_type_hook) )
    }
  }

  const untag     = from
  _hash_from      = untag_hash
  const hash_from = untag_hash
}
# module Xchg {}
