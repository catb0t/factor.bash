#!ruby

##  ABCs, Abstract Base Classes and field/method generation
##    Copyright Cat Stevens 2018
##  This program is free software: you can redistribute it and/or modify
##    it under the terms of the GNU General Public License as published by
##    the Free Software Foundation, either version 3 of the License, or
##    (at your option) any later version.
##
##    This program is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
##
##    You should have received a copy of the GNU General Public License
##    along with this program.  If not, see <https://www.gnu.org/licenses/>.

include lib::frext

module SProcess {
  define Hash WANT_ALL_VALS = :(:typename => true, :default_val => true, :custom_blocks => true)
  define Hash WANT_EXCLUDE_BLOCKS = :(typename => true, :default_val => true)
  define Block CUSTOM_BLOCKS_DEFAULT = { Hash() }

  func process_serial_prop_rhs (callers < FRExt::NonEmptyArrStr, String name, Object obj, Hash want_vals) -> Hash {
    const FN = __FUNC_NAME__

    const is_fqa = obj.is_an_object(Array)

    want_vals.rescope{
      # maybe the following can be vectorised?
      if ( !is_fqa ) {
        obj.is_typename || die ("RHS in serial property declaration '#{name}' isn't a typename: '#{obj}' (ref #{obj.ref}) (perhaps you accidentally initialised the object?)\n\t#{__FUNC_NAME__}: called from: #{callers.reverse.join(' < ')}")

        .clobber_existing_by( Hash(
          :typename => { obj },
          :default_val => { TypeUtils::maybe_call_custom_init( obj ) },
          :custom_blocks => SProcess::CUSTOM_BLOCKS_DEFAULT
        ) )
      } else {
        die (
          "#{__FILE__}:#{__LINE__}: #{FN}: malformed array in RHS when declaring field '#{name}': must have positive length (1, 2 or 3)"
        ) if ( is_fqa && !obj )

        if (obj.len == 1) {
          __FUNC__([@|callers, :V_recursing] name, obj[0], _ )
        } else {
          defined(obj[2]) && ( obj[2].is_an_object(Hash) \
            || die "#{__FILE__}:#{__LINE__}: #{FN}: malformed custom get/set blocks in RHS when declaring field '#{name}': RHS item \#3: want type 'Hash'; got '#{obj[2].ref}'"
          )

          .clobber_existing_by( Hash(
            :typename => { obj[0] },
            :default_val => { obj[1] \\ TypeUtils::maybe_call_custom_init( obj[0] ) },
            :custom_blocks => { obj[2] \\ Hash() }
          ) )
        }
      }
    }
  }
}

class Serializable {
  has String _k_svalue = :_serial_value

  -> _grep_serial_properties (Set incl, Set excl) is cached -> Hash {
    self.grep_methods{ |n| n ~~ /^serial_properties/ } \
      .values.map{ const props = _(); ( incl ? (props & incl) : props ) - excl }.merge_reduce \\ Hash()
  }

  -> _do_serial (Block d, incl = Set(), excl = Set()) {
    self._grep_serial_properties(incl, excl).map_kv(d)
  }

  -> _is_serialized_obj (Object obj, optimized = false) {
    if (__OPTIMIZED__ || optimized) {
      ( obj.is_an_object(Hash) && (obj{self._k_svalue} \\ Regex).is_an_object(Hash) )
    } else {
      ( obj.is_an_object(Hash) && obj.keys==[self._k_svalue] && obj{self._k_svalue}.is_an_object(Hash) )
    }
  }

  -> _find_getter (Array callers, String field_name, Hash props) {
    const MN = __METHOD_NAME__

    (if ( self.is_property([@|callers, MN, :V_is_prop_test], field_name, props{:default_val}) ) {
      # say "\t#{field_name} is a property"
      *TypeUtils::object_hash_ref([@|callers, MN, :V_is_prop], self, field_name)
    } else {
      self.has_overload( Hash(
        :callers => [@|callers, MN, :V_else_branch],
        :give_return => true,
        :name => field_name,
      ) ).rescope{
        .{:state} || die ("#{__FILE__}:#{__LINE__}: #{__METHOD_NAME__}: #{field_name} (#{props{:typename}}) " + 'appears to be neither a property nor declared getter: reason: ' + .{:why})
        # say "\tvalue: #{.{:return}}"
        .{:return}
      }
    } \\ props{:default_val})
  }

  method serialize (incl = Set(), excl = Set(), _recursing = false, Array callers = ["(main)"]) -> Hash {
    const MN = __METHOD_NAME__
    const RC = (_recursing ? :R_recursing : :R_not_recursing)

    self._do_serial(incl: incl, excl: excl, {
        |field_name, field_rhs|

      # say "serialize #{field_name}"
      self._find_getter(
        [@|callers, MN, RC, :V_step2],
        field_name,
        SProcess::process_serial_prop_rhs(
          [@|callers, MN, RC, :V_step1],
          field_name,
          field_rhs,
          SProcess::WANT_EXCLUDE_BLOCKS
        )
      ).rescope{
        ( (field_name) => (
          TypeUtils::is_serializable(_)
            ? Hash( (self._k_svalue) => .serialize( incl: incl, excl: excl, _recursing: true, callers: [@|callers, MN, RC] ) )
            : _
        ) )
      }
      # say "serialize '#{field_name}': type '#{type}': value: #{value}"
      # assert(defined(value), "#{__FILE__}:#{__LINE__}: Assertion `self.#{field_name} != nil' failed!")
    })
  }

  /* bi-recursive with unserialize */ # /
  -> _maybe_unserialize (Array callers, Array recur_kwargs, entry, Hash props) -> (Array, Object, Object) {
    # say "\tdefined props default_val: #{defined(props{:default_val})}"
    (callers, props{:typename}, if (!self._is_serialized_obj(entry)) {
      entry
    } else {
      TypeUtils::maybe_call_custom_init( props{:default_val} ) \
        .unserialize( entry{self._k_svalue}, @|recur_kwargs, callers: [@|callers, __METHOD_NAME__, :V_else_branch] )
    } \\ props{:default_val}) # this defined-or technically isn't necessary but why isn't it?
  }

  -> _find_setter (Array callers, String field_name, Object new_val) -> Bool {
    const MN = __METHOD_NAME__
    if ( self.is_property([@|callers, MN, :V_is_prop_test], field_name, new_val) ) {
      *TypeUtils::object_hash_ref([@|callers, MN, :V_is_prop], self, field_name) = new_val
      true
    } else {
      self.has_overload( Hash(
        :callers => [@|callers, MN, :V_else_branch],
        :name => field_name,
        :args => [new_val]
      ) ){:state}
    }
  }

  /* bi-recursive with _maybe_unserialize */ # /
  method unserialize (Hash data, incl = Set(), excl = Set(), _recursing = false, Array callers = ["(main)"] ) -> __CLASS__ {
    const MN = __METHOD_NAME__
    const RC = (_recursing ? :R_recursing : :R_not_recursing)

    self._do_serial(incl: incl, excl: excl, {
        |field_name, field_rhs|

      # say "#{field_name}: #{data{field_name}.dump}"
      Combi::rescope( self._maybe_unserialize(
        [@|callers, MN, RC, :V_step2],
        [incl: incl, excl: excl, _recursing: _recursing],
        data{field_name},
        SProcess::process_serial_prop_rhs(
          [@|callers, MN, RC, :V_step1],
          field_name,
          field_rhs,
          SProcess::WANT_EXCLUDE_BLOCKS
        )
      ) )({
          |rs_callers, typename, derived|
        # say "\tdefined derived: #{defined(derived)}"
        self._find_setter([@|rs_callers, MN, RC, :V_rescope], field_name, derived) \
          || die ("#{__FILE__}:#{__LINE__}: #{__METHOD_NAME__}: #{field_name} (#{typename}) (value #{derived}) " + 'appears to be neither a property nor declared setter')
      })
    })
    self
  }
}

# use the serializable functionality to equate two objects
/* abstract interface */ # /
class SeriallyEquatable < Serializable {
  -> _serial_eq (other, incl = Set(), excl = Set()) -> Bool {

    if ( other.is_a(Serializable) ) {
      other.serialize(incl: incl, excl: excl) == self.serialize(incl: incl, excl: excl)

    # somehow... maybe other is our superclass
    } elsif (other ~~ self) {
     [self, other].map{
       |obj| self._do_serial(incl: incl, excl: excl, { obj.method(_)() } )
     }«==»

     # TODO: use object_hash_ref here
    } else { self._do_serial(incl: incl, excl: excl, { other{_} == self{_} } ).all }
  }
  method == (o) { self._serial_eq(o) }
  # method <=> (o, p) { self.cmp(o, p) }
}


func _call_methods_blocks_by (Object obj, Regex name_match) {
  # 0..30 -> map{ "sdf"+.to_s+"abcde" }.sort{ |l, r| [l, r].all{ _ ~~ /(\d+)/ } ? [l, r].map{ (_ =~ /(\d+)/ )[0].to_n }.reduce{ |p, q| p <=> q } : (l <=> r) }
  obj.grep_sorted_map_methods(
    { |name, _| name ~~ name_match },
    {
        |l, r|
      # if (!defined(l) || !defined(r)) { return 0 }
      define Regex NUMERIC = /^(\d+)/
      Combi::binop(
        [l, r].map{ ( .key =~ ( name_match + /(?<unique_part>\d+.*)/ ) ).named_captures(){:unique_part} } \
        .rescope{
          .all{ _ ~~ NUMERIC }
            ? .map{ (_ =~ NUMERIC )[0].to_n }
            : _
        }...
      )( '<=>' ) # '
    },
    { |_, calls| calls().each{ |block| block.run(obj) } }
  )
}

class ModularInit {
  method init {
    _call_methods_blocks_by(self, /^init_steps_/)
    self
  }
}

# if this is defined in SeriallyAccessible and inherited, its contents will be
#   duplicated or buggy, and will cause infinite recursion in subclasses
define Array global_init_steps_sa_base = [
  { ._property_generator },
  { ._do_serial( ._bound_accessor_generator ) },
]

class SeriallyAccessible << ModularInit, SeriallyEquatable {
  has Array init_steps_00_sa_base = global_init_steps_sa_base
  method _bound_accessor_generator {
    const MN = __METHOD_NAME__
    {
        |field_name, field_rhs|
      # say "#{field_name} #{field_rhs.refaddr} #{field_rhs}"
      SProcess::process_serial_prop_rhs(
        [MN, :V_bound_block, :V_first_step],
        field_name,
        field_rhs,
        SProcess::WANT_ALL_VALS
      ).rescope{
        const typename = .{:typename}
        const default_val = .{:default_val}
        const custom_blocks = .{:custom_blocks}

        (typename ~~ default_val) \
          || die (
            "#{__FILE__}:#{__LINE__}: #{__METHOD_NAME__}: type mismatch when generating default value for '#{field_name}': ",
            "want '#{typename}'; got '#{default_val.class}' ('#{default_val.dump}')"
        )

        # no underscore on field_name here
        self.is_property([MN, :V_bound_block], field_name, default_val) && die (self.class+' already has raw property named \''+field_name+'\'; not overwriting it (did you forget to declare the property with \'_'+field_name+'\'?)')

        # create the private slot
        # say "#{__METHOD_NAME__}: setting _#{field_name} to '#{default_val.dump}'"
        # self{:_ + field_name} = default_val

        # need an underscore here
        *TypeUtils::object_hash_ref([MN, :V_bound_block], self, :_ + field_name) = default_val
        # say "#{__METHOD_NAME__}: set _#{field_name} to #{self{:_ + field_name}.dump}"

        const Block setter_prelude = {
          .is_a(typename) \
            || die(
              "#{__FILE__}:#{__LINE__}: #{__METHOD_NAME__}:  ",
              "type mismatch in generated setter '#{field_name}': want '#{typename}'; got '#{_.class}'  ('#{_.dump}')"
          )
        }


        func acc (self) {
          # say "get field #{field_name}"
          # say "custom_blocks: #{custom_blocks}"
          static var custom_getter = custom_blocks{:get}
          # say "get field #{field_name} (#{typename}) with #{custom_getter}"
          if (custom_getter) {
            custom_getter.run(self)
          } else {
            *TypeUtils::object_hash_ref([MN, :V_gen_accessor, :V_gen_getter, :V_builtin_getter], self, :_ + field_name)
          }
        }

        func acc (self, new_val) -> __CLASS__ {
          static var custom_setter = custom_blocks{:set}
          setter_prelude.run(new_val)
          # say "\tset field #{field_name} to #{new_val} (#{typename})"
          if (custom_setter) {
            custom_setter.run(self, new_val) \\ self
          } else {
            # say "\tnew value for #{field_name}: #{new_val}"
            *TypeUtils::object_hash_ref(
              [MN, :V_gen_accessor, :V_gen_setter, :V_builtin_setter],
              self,
              # note the underscore
              :_ + field_name
            ) = new_val
            self
            # self{:_ + field_name} = new_val; self
          }
        }
        __CLASS__.def_method(field_name, acc)
        # say "declared accessor for #{field_name}"
      }
    }
  }

  method _property_generator {
    define Regex serial_pg_name = /^serial_property_generator(\w+)$/

    self.grep_methods{ _ ~~ serial_pg_name } \
      .map_kv{
          |_, calls|
        # const method_name = (:serial_properties + (name =~ serial_pg_name)[0])
        # say "createproperty #{method_name}"
        # func new_ser_props (self) { const r = calls().map{ .run(self) }; say r; r }
        # this does not create an entry in .methods
        # __CLASS__.def_method( method_name, new_ser_props )
        calls().each{ .run(self).each_kv( self._bound_accessor_generator ) }
      }
  }

}

class Lockable {
  has Bool _impl_locked = false
  has String _impl_err_write_locked = 'attempt of write to locked '+__CLASS_NAME__+' object!'

  -> locked { self._impl_locked }
  -> unlocked { !self._impl_locked }
  -> state (String s) { s ~~ /^unl/ ? !self._impl_locked : self._impl_locked }
  -> lock { self._impl_locked = true; self }
  -> lock (Bool b) { self._impl_locked = b; self }
  -> unlock { self._impl_locked = false; self }
}
