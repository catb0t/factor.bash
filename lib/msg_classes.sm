#! ruby

##  MsgClasses, classifying Sidef exceptions
##    Copyright Cat Stevens 2018
##  This program is free software: you can redistribute it and/or modify
##    it under the terms of the GNU General Public License as published by
##    the Free Software Foundation, either version 3 of the License, or
##    (at your option) any later version.
##
##    This program is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
##
##    You should have received a copy of the GNU General Public License
##    along with this program.  If not, see <https://www.gnu.org/licenses/>.

include sidefext::combi
include sidefext::iterable # Hash.change_extant_keys

module MsgTypes {
  define NO_ERROR      = :NO_ERROR
  define NO_METHOD     = :NO_METHOD
  define BAD_ENCODING  = :BAD_ENCODING
  define PERL_COMPILER = :PERL_COMPILER
  define PERL_RUNTIME  = :PERL_RUNTIME
  define UNIMPLEMENTED = :UNIMPLEMENTED
  define OTHER_UNCLASSIFIED    = :OTHER_UNCLASSIFIED
  define CLASS_DOES_NOT_MATCH  = :CLASS_DOES_NOT_MATCH
  define BLOCK_DOES_NOT_MATCH  = :BLOCK_DOES_NOT_MATCH
  define STRUCT_DOES_NOT_MATCH = :STRUCT_DOES_NOT_MATCH

  define Set METHOD_EXISTS    = Set(MsgTypes::NO_ERROR, MsgTypes::BLOCK_DOES_NOT_MATCH, MsgTypes::BAD_ENCODING)
  define Set OVERLOAD_EXISTS  = Set(MsgTypes::NO_ERROR, MsgTypes::BAD_ENCODING)
  define Set NOT_PROPERTY     = Set(MsgTypes::NO_METHOD, MsgTypes::BLOCK_DOES_NOT_MATCH, MsgTypes::BAD_ENCODING)
  define Set DOES_NOT_MATCH   = Set(MsgTypes::CLASS_DOES_NOT_MATCH, MsgTypes::BLOCK_DOES_NOT_MATCH, MsgTypes::STRUCT_DOES_NOT_MATCH)

  define Array MSG_REGEXES = [
    MsgTypes::NO_ERROR ： /^$/
    MsgTypes::NO_ERROR ： /^The operation completed successfully\.$/i,
    MsgTypes::NO_METHOD ：
      /^(?:\[AUTOLOAD\] )?Undefined method `(?<method_name>.*)' called from (?<method_invoked_from>.*)/,
    MsgTypes::BLOCK_DOES_NOT_MATCH ：
      /^(?:\[ERROR\] )?(?<block_type>func|method) `(?<block_name>[\S\s]*)` does not match \g{block_name}\((?<block_tried_proto>.*)\), invoked as \g{block_name}\((?<block_tried_invoke>[\S\s]*)\)\n\nPossible candidates are: ?\n(?<block_dispatches>[\S\s]*)\n*/m,
    MsgTypes::CLASS_DOES_NOT_MATCH ：
      /^(?:\[ERROR\] )?class `(?<class_name>[\S\s]*)` does not match \g{class_name}\((?<class_tried_proto>.*)\), invoked as \g{class_name}\((?<class_tried_invoke>[\S\s]*)\)\n\nPossible candidates are: ?\n(?<class_dispatches>[\S\s]*)\n*/m,
    MsgTypes::STRUCT_DOES_NOT_MATCH ：
    /^(?:\[ERROR\] )?struct `(?<struct_name>[\S\s]*)` does not match \g{struct_name}\((?<struct_tried_proto>.*)\), invoked as \g{struct_name}\((?<struct_tried_invoke>[\S\s]*)\)\n\nPossible candidates are: ?\n(?<struct_dispatches>[\S\s]*)\n*/m,
    MsgTypes::BAD_ENCODING ： /^Unknown encoding '(?<encoding>.*)'/,
    MsgTypes::PERL_RUNTIME ：
      /^(?:Not an? (?<tried_ref>.*) reference|Can't use (?<tried_ref_type>.*) \((?<tried_ref_with>"[^"]+")\) as an? (?<tried_ref>.*) ref while.*) at .*/,
    MsgTypes::PERL_COMPILER ： /Bareword/
    MsgTypes::UNIMPLEMENTED ： /Unimplemented at (?<file>.+) line (?<line>[-\d]+)$/
    MsgTypes::OTHER_UNCLASSIFIED ： /^(?<value>[\S\s]*)/
    # Pair(:PERL_INTERNAL, /^(.*)/)
  ]
}


func dispatches_cleanup (String ds, Str type) -> Hash {
  define Hash rs = :( :block  => /\G\s+(?<block_name>.+)\((?<block_dispatch>.*?)\)/  ,
                      :class  => /\G\s+(?<class_name>.+)\((?<class_dispatch>.*?)\)/  ,
                      :struct => /\G\s+(?<struct_name>.+)\((?<struct_dispatch>.*?)\)/ )
  # assert( type ~~ Set(:block, :class, :struct) )
  rs{type}.global_matches(ds, {
      |i, _|
    .named_captures.map_kv{
        |k, v|
      ( ("#{k}:#{i}") => v )
    }
  } ).reduce('merge') \\ Hash()
}

func msg_fields (m) is cached -> Hash {
  m.named_captures.change_extant_keys(
    [:block, :class, :struct].map{ (
      (.+:_dispatches) =>
        { |s| dispatches_cleanup(s, _) }
    ) }.to_h
  )
}

func classify (String msg) is cached -> (String, Object) {
  with ( MsgTypes::MSG_REGEXES.find{ .value ~~ msg } ) {
    (.key, msg_fields(msg =~ .value) )
  } else {
    die "#{__FUNC_NAME__}: can't classify THAT!\n\t#{msg.dump}"
  }
}

if (__FILE__ == __MAIN__) {
  DATA.slurp.split("\n%\n").each{
    Combi::apply( classify(.apply_escapes) )(
      { assert_ne(_, MsgTypes::OTHER_UNCLASSIFIED); _+' => ' },
      Block.identity,
    ).join.say
  }
  say "*** Test passed!"
}


__DATA__
[ERROR] func `MaybeArr` does not match MaybeArr(Number), invoked as MaybeArr(2)

Possible candidates are:
    MaybeArr()
    MaybeArr(Array)
%
method `GG` does not match GG(Number), invoked as GG(2)

Possible candidates are:
    GG()
    GG(Num)
    GG(GGGG)
    GG(GGGG, AAAA)
%
[AUTOLOAD] Undefined method `Hash.asdasd' called from main()
%
Unknown encoding '' at /home/cat/perl5/lib/perl5/Sidef/Types/String/String.pm line 1179.
%
Not a HASH reference at (eval 30) line 5.
%
Can't use string ("Sidef::Types::Hash::Hash") as a HASH ref while "strict refs" in use at (eval 38) line 5.
%
method `x` does not match x(X, Number), invoked as x(X(), 1)\n\nPossible candidates are: \n    X.x(self)\n
%
class `BlobSums` does not match BlobSums(NamedParam, Pair, Pair, Pair), invoked as BlobSums(NamedParam("algo", "sha256"), Pair("vm", "2e160987cb44223343d38479a97e202e8b9c0e56610c4fec5fde8872f37802e2"), Pair("lib", "119ce9c8820501c90788d22ec1338070a62f88241557d032ce0075f044a4f0b3"), Pair("boot", "e3512cc438154985d2713f88d4624b241a048c4d7b4bbaa157bbae1ac0736d8e"))

Possible candidates are:
    BlobSums(String algo, String vm, String lib, String boot)
%

%
The operation completed successfully.
%
func `classify` does not match classify(nil), invoked as classify(nil)

Possible candidates are:
    lib::msg_classes::classify(String msg)
%
struct `BlobStatus` does not match BlobStatus(NamedParam, NamedParam, NamedParam), invoked as BlobStatus(NamedParam(\"exists\", false), NamedParam(\"recompiled\", false), NamedParam(\"checksum_match\", false))\n\nPossible candidates are: \n    BlobStatus(Bool exists, Define checksum_match, Bool recompiled)\n
%
struct `BlobStatus` does not match BlobStatus(NamedParam, NamedParam, NamedParam), invoked as BlobStatus(NamedParam("exists", false), NamedParam("recompiled", false), NamedParam("checksum_match", false))

Possible candidates are:
    BlobStatus(Bool exists, Define checksum_match, Bool recompiled)
%
Unimplemented at multifactor.sm line 541
