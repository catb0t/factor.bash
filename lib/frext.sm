#! ruby

##  Functional and Reflective EXTensions for Sidef metaprogramming
##    Copyright Cat Stevens 2018
##  This program is free software: you can redistribute it and/or modify
##    it under the terms of the GNU General Public License as published by
##    the Free Software Foundation, either version 3 of the License, or
##    (at your option) any later version.
##
##    This program is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
##
##    You should have received a copy of the GNU General Public License
##    along with this program.  If not, see <https://www.gnu.org/licenses/>.

include lib::msg_classes
include lib::combi

module FRExt {
  subset ArrStr < Array, String { .len }

  class Object {
    # method form of "with", but defined-agnostic
    method rescope (b) { b.run(self) }
    method cleave (*b) { b.map{ .run(self) } }

    # internal; doesn't care about overloads
    /* -> respond_to (String name, *_) -> Bool { self.can(name, _...) } */

    method declares_method (String name) -> Hash {
      self.grep_methods{ |n, _| n ~~ name }
    }

    # test if it can be called with the specific number and type of arguments
    method has_overload (Hash overload_spec) -> Hash {
      ( Hash(
        :clone_call => false,
        :give_return => false,
        :args => [],
        :debug => false
      ) + overload_spec ).rescope{
          |spec|
        die 'invalid has_overload spec: \'callers\' must be a non-empty array of non-empty strings' \
          if ( ! spec{:callers}.cleave( { _ }, { .is_an(Array) }, { .all }, { .all{ .is_a(String) } } ).all  )

        const invalid_caller = 'invalid has_overload spec from ('+spec{:callers}.join(' > ')+'): '

        die invalid_caller+'\'name\' must be nonempty string' \
          if ( ! spec{:name}.cleave( { _ }, { .is_a(String) }, { .respond_to(:len) } ).all )

        die invalid_caller+'\'args\' must be iterable' \
          if ( ! spec{:args}.respond_to("...") )

        try {
          if (spec{:debug}) {
            say "\t** has_overload < (#{spec{:callers}.reverse.join(' < ')}):\n\t\t.method( '#{spec{:name}}' )( #{spec{:args}.map{.dump}.join(', ')} ) ;; clone_call: #{spec{:clone_call}}"
          }

          const r = ( spec{:clone_call} ? self.dclone : self).method( spec{:name} )( spec{:args}... )
          spec{:debug} && say "\t\t\tinvocation worked!"

          :( :state => true, :return => (spec{:give_return} ? r : nil) )

        } catch {
            |_e, msg|
          Combi::rescope( lib::msg_classes::classify( msg) )({
              |type, fields|
            if (spec{:debug}) {
              say("\t\t\t"+'invocation failed! reason: ' + type + ' => ' +
                fields.grep_kv{ .!= :block_tried_invoke }
              )
            }

            :(
              :state => false,
              :why => type,
              :details => fields
            )
          })
        }
      }
    }

    # declared, exists, can be called
    method has_public_concrete_method (callers < ArrStr, String name) {
      self.cleave(
        { .respond_to(name) },
        { .declares_method(name) },
        { .has_overload( Hash(
            :callers => [@|callers, __METHOD_NAME__],
            :name => name,
            :clone_call => true,
            # :catch_msg_ref => \var String msg
          ) ).rescope{
            .{:state} || (MsgTypes::METHOD_EXISTS.contains( .{:why} ))
          }
        }
      ).all
    }

    method has_public_concrete_overload (callers < ArrStr, Str name, *args) {
      self.cleave(
        { .respond_to(name) },
        { .declares_method(name) },
        { .has_overload( Hash(
            :callers => [@|callers, __METHOD_NAME__],
            :name => name,
            :clone_call => true,
            :args => args
          ) ).rescope{
            .{:state} || (MsgTypes::OVERLOAD_EXISTS.contains( .{:why} ) )
          }
        }
      ).all
    }

    # TODO: use hash as arg / return val, and allow getting the value etc (prevent replaying as much as possible)
    method is_property (callers < ArrStr, Str name, Object type_example_arg) -> Bool {
      # self-respecting explicitly declared accessors are typed, and not varargs
      # field accessors generated with "has X" are untyped varargs
      self.has_overload( Hash(
          :callers => [@|callers, __METHOD_NAME__],
          :name => name,
          :clone_call => true,
          :args => [type_example_arg, :extra_garbage_arg],
          # :debug => true
      ) ).rescope{
        # say "is_property: #{self.class}::#{name} :: #{.{:state}}"
        .{:state} || ( ! [MsgTypes::NO_METHOD, MsgTypes::DOES_NOT_MATCH, MsgTypes::BAD_ENCODING].contains( .{:why} ) )
      }
    }

    method grep_methods (Block b) {
      self.methods.grep_kv(b)
    }
    method grep_map_methods (Block g, Block m) {
      self.grep_methods(g).map_kv(m)
    }
  }

  class Array {
    method all { self.all{ _ } }
    method merge_reduce { self.reduce{ |l, r| l.merge(r) } }
  }

  class Hash {
    # inverse of + / merge: only update keys that are already in the LHS
    method clobber_existing_by (other) {
      self.map_kv{
          |k, v|
        ((k) => if ( v && other.has_key(k) ) {
          other{k}.run(k, v)
        } else {
          v
        })
      }
    }
  }

  module TypeUtils {
    func is_serializable (Object obj) {
      obj.respond_to(:serial_properties)
      # obj.has_overload( Hash( :callers => __FUNC_NAME__, :name => :serial_properties) )
    }
    # Fully-Qualified Sidef::Runtime:92349879234::main::Typename Typename
    #   to Universal Main-Derived Typename main::Typename
    func fqtn_to_umdtn (String fqtn) -> String {
      (/^Sidef::Runtime::\d+::(main::.+)$/ =~ fqtn)[0]
    }

    func is_typename (Object obj) -> Bool {
      # print "#{obj} "
      [:compile_to_perl, :code_interactive].all{
        obj.declares_method(_) # .rescope{ |b| say("\tdeclares #{_}: #{Bool(b)}"); b }
      } && obj.refaddr==0
    }

    # is Fully-Qualified Constructed Object
    func is_fqco (obj, must_have_prop = false) -> Bool {
    # say "is fqco #{obj} #{must_have_prop}"
      Bool( !is_typename(obj) && (must_have_prop ? obj.declares_method(must_have_prop) : true) )
    }

    func is_a_fqco (obj, typename, must_have_prop = false) {
    # say "is a + is fqco #{obj} #{typename} #{must_have_prop}"
      obj.is_a(typename) && TypeUtils::is_fqco(obj, must_have_prop: must_have_prop)
    }

    func maybe_call_custom_init (Object obj) {
      if ( obj.respond_to(:INIT_METHOD_NAME) ) {

        obj.method( obj.INIT_METHOD_NAME )()
      } elsif ( TypeUtils::is_typename(obj) ) {
        # invoke raw typenames
        obj()
      } else {
        obj
      }
    }

    func object_hash_ref (callers < FRExt::ArrStr, Object obj, String field_name) {
      try {
        # say "#{callers.last}: \t\tREF PROPERTY #{obj.class} #{field_name}"
        \(obj{field_name})
      } catch {
          |_e, msg|
        Combi::rescope( lib::msg_classes::classify(msg) )({
            |type, fields|
          die "\t** object_hash_ref < (#{callers.reverse.join(' < ')}):\n\t\t#{obj.class} { #{field_name} } FAILED! reason: #{type}"
        })
      }
    }
  }
}

assert_eq( Object.has_overload(:(:callers => [:main], :name => :respond_to, :give_return => true)), :( :return => false, :state => true ) )
