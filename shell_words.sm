#! ruby
#! sidef -WkP8
#`(exit the shell) {
  eval 'exec sidef -WkP8 $0 ${1+"$@"}'
}
##  shell_words, part of MultiFactor
##    Copyright Cat Stevens 2018
##  This program is free software: you can redistribute it and/or modify
##    it under the terms of the GNU General Public License as published by
##    the Free Software Foundation, either version 3 of the License, or
##    (at your option) any later version.
##
##    This program is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
##
##    You should have received a copy of the GNU General Public License
##    along with this program.  If not, see <https://www.gnu.org/licenses/>.

module Command {
  define Regex RETVAL_REGEX = /__RETURNED=(\d+)/

  func spawn_se (Bool output = false, *cmdline) -> Bool {
    $| = 1

    STDERR.say("\t\b\b-> #{cmdline.join(' ')}")
    0 == Number(
      (Pipe( [cmdline..., ";", "echo", '"__RETURNED=$?\n"'].join(' ') ) \
        .open_r.cleave(
          { .autoflush(true) },
          { "\n\t\t".print if (output) },
          {
            var c = ''
            .each_char{
                |b|
              if (output) {
                if (c.last == "\n") { "\t\t".print }
                b.print
              }
              c += b
            }
            c
          }
        ).last \
        .lines.find{ _ ~~ RETVAL_REGEX } =~ RETVAL_REGEX
      )[0].to_n
    )
  }
  func ql (Array args) -> String {
    args.map{ "#{_.quotemeta} " }.join
  }
  func make (Bool output = false, *args) -> Bool {
    Command::spawn_se('make', '-j', args..., output: output)
  }
  func nmake (Bool output = false, *args) -> Bool {
    Command::spawn_se('set CL=/MP & nmake', args..., output: output)
  }
}

# `build.sh` bash functions
# THEIR utilities, re-implemented in Sidef
module BuildSh {

  define Regex VERSION_REGEX = /VERSION = ([0-9]+\.[0-9]+)/
  define Regex REPRODUCIBLE_REGEX = /REPRODUCIBLE/

  define File GNU_MAKEFILE = %f(GNUmakefile)
  define File N_MAKEFILE = %f(Nmakefile)

  define String NOT_A_GIT_REPO = '^~not a git repository~^'
  const Array NOT_GIT_SYMS = [ BuildSh::NOT_A_GIT_REPO[0..2] ]

  include Command
  -> downloader {
    'LWP::UserAgent'.require.new(show_progress => 1)
  }
  -> make_http_request (url) {
    var resp = BuildSh::downloader().get(url)
    resp.is_success ? resp.decoded_content : false
  }
  -> find_programs (String kind, Array ps) is cached -> String {
    STDERR.say("Look for '#{kind}': #{ps.join(', ')}...")
    for p in ps {
      const s = `which #{p.quotemeta}`.chomp
      if (Number($?) == 0) {
        STDERR.say("    found #{s}")
        return s
      }
    }
    die "no #{kind}"
  }
  # TODO: not *required*
  # -> check_cc_version (String name) is cached -> Bool {
  #   Bool(name)
  #   ...
  # }
  -> cc () is cached -> String {
    BuildSh::find_programs(:cc, %w(clang gcc cc))
  }
  -> cxx () is cached -> String {
    BuildSh::find_programs(:cxx, %w(clang++ g++ c++ cpp))
  }
  # NOTE: os_type is distinct to osname
  -> os_name (n = nil) is cached -> String {
    given (n || Sys.osname) {
      when (/(?:windows|cygwin)/i) { :windows }
      when (/(?:macos|darwin)/)  { :macos }
      when (/(?:linux|mingw)/)  { :linux }
      when (:bsd)               { :bsd }
      when (:haiku)             { :haiku }
      default { die "Unknown osname: #{Sys.osname}" }
    }
  }
  -> os_type (t = nil) is cached -> String {
    given ( t || BuildSh::os_name() ) {
      when (/(?:linux|darwin|macos|bsd|mingw)/i) { :unix }
      when (/(?:windows|cygwin)/i) { :windows }
      case ( %w(haiku).contains(_) ) { BuildSh::os_name() }
      default { die "Can't convert osname to os_type: #{Sys.osname}" }
    }
  }
  -> arch_name () is cached -> String {
    const uname = `uname -m`.chomp
    if ( [:ppc64, "Power Macintosh"].any{ uname.contains(_) } ) {
      :ppc
    } else {
      :x86
    }
  }
  -> c_word_size () is cached -> String {
    define File ws_binary = %f(factor_word_size)
    `echo '#include <stdio.h>
    int main(){printf(\"%ld\",(long)(8*sizeof(void*)));}' | #{BuildSh::cc()} -xc -o#{ws_binary} -`

    die "couldn't call the C compiler: #{$!}" \
      if (Number($?) != 0)

    # NOTE: can't be const, or else the value will be discarded
    var String ws = `./#{ws_binary}`
    if (Number($?) != 0) {
      var e = $!
      ws_binary.remove
      die "couldn't run the word size program: #{e}"
    }
    ws_binary.remove
    ws
  }
  -> intel_macosx_word_size () is cached -> String {
    `#{BuildSh::find_programs(:sysctl, [:sysctl])} machdep.cpu.extfeatures | grep EM64T >/dev/null`
    (Number($?)==0 ? :64 : :32)
  }
  -> word_size () is cached -> String {
    if (BuildSh::os_name()~~:macos && BuildSh::arch_name()~~:x86) {
      BuildSh::intel_macosx_word_size()
    } else {
      BuildSh::c_word_size()
    }
  }

  -> generate_make_targets () is cached -> Hash {
    const (
      ot = BuildSh::os_type(),
      on = BuildSh::os_name(),
      an = BuildSh::arch_name(),
      ws = BuildSh::word_size()
    )
    Hash(
      :make_image => "#{on}-#{an}.#{ws}",                  # MAKE_IMAGE_TARGET
      :make_vm => "#{on}-#{an}-#{ws}",                     # MAKE_TARGET
      :boot_image_base => "#{ot}-#{an}.#{ws}",             # boot image base (no analogue)
      :boot_image => File("boot.#{ot}-#{an}.#{ws}.image"), # BOOT_IMAGE
    )
  }

  # lots of things aren't allowed in a git branchname
  # see `man git check-ref-format` and https://stackoverflow.com/a/3651867/4532996
  # we're going to use just ~ and ^ internally to identify non-git strings
  -> is_git_ref_name (Str b) is cached {
    b!=BuildSh::NOT_A_GIT_REPO && !( BuildSh::NOT_GIT_SYMS.any{ b.contains(_) } )
  }

  # check the outputs of these with is_git_ref_name:

  # returning `nil` from these is not an option, because `nil` is an empty string
  -> git_branch () is cached {
    const branch = `git rev-parse --abbrev-ref HEAD`
    (Number($?)==0 ? branch.chomp : BuildSh::NOT_A_GIT_REPO)
  }

  -> git_hash () is cached {
    const hash = `git rev-parse HEAD`
    (Number($?)==0 ? hash.chomp : BuildSh::NOT_A_GIT_REPO)
  }

  -> try_git (Str operation, Str caller_name, Bool fatal = true) is cached {
    const git_output = eval("BuildSh::git_#{operation}")()
    if (! BuildSh::is_git_ref_name(git_output) ) {
      die "[FATAL] #{__FUNC_NAME__}: git_#{operation}: #{caller_name} requires #{Dir.cwd} to be a git repository" if (fatal)
      return false
    }
    git_output
  }

  -> is_git () is cached -> Bool {
    [:branch, :hash].all{ BuildSh::try_git(_, __FUNC_NAME__, fatal: false) }
  }

  -> platform_vm_ext (n = nil) is cached -> String {
    given ( n || BuildSh::os_name() ) {
      when (:windows) { ".exe" }
      default { "" }
    }
  }

  -> platform_lib_name (n = nil) is cached -> Array {
    const N = (n || BuildSh::os_name())
    Pair(
      given (N) {
        when (:windows) { "" }
        default { "lib" }
      },
      given (N) {
        when (:windows) { ".dll" }
        when (:macos) { ".dylib" }
        default { ".a" }
      }
    )
  }

  -> platform_makefile (n = nil) is cached -> File {
    const N = (n || BuildSh::os_name())
    ( N ~~ :windows ? BuildSh::N_MAKEFILE : BuildSh::GNU_MAKEFILE )
  }

  -> factor_version () is cached {
    const result = BuildSh::platform_makefile().open_r.lines.find{ _ ~~ BuildSh::VERSION_REGEX } \
      || die "[FATAL] #{__FUNC_NAME__}: can't find a VERSION in GNUmakefile #{BuildSh::platform_makefile().abs}"
    (BuildSh::VERSION_REGEX =~ result)[0]
  }

  -> feature_reproducible () is cached -> Bool {
    Bool( BuildSh::platform_makefile().open_r.lines.find{ _ ~~ BuildSh::REPRODUCIBLE_REGEX } )
  }

  # -> platform_make (*args) {
  #   const N = (n || BuildSh::os_name())
  #   ( N ~~ :windows ? ['set CL=/MP & nmake'] : ['make', '-j'] )
  # }

  -> make_clean (Bool output = false) {
    Command::make(:clean, output: output)
  }

  # bo_target: BuiltObj
  -> make_factor ( bo_target, Bool output = false ) {
    # var (pre, suf) = BuildSh::platform_lib_name()...
    (BuildSh::generate_make_targets(){:make_vm} -> cleave(
      { say "Building '#{_}' with infinite cores" },
      { Command::make(
          _,
          (BuildSh::feature_reproducible ? 'REPRODUCIBLE=1' : ' SITE_CFLAGS="-D__DATE__=\'\"[reproducible-workaround]\"\' -D__TIME__=\'\"\"\'" '),
          output: output
        )
      }
    ).last \
      && :factor.cleave(
        [:vm, :lib].map{
            |name|
          { |factor|
            # const f = File( factor.join( bo_target.method(name+:_format)()[0, 2] ) )
            # say "file #{f} #{bo_target.method(name+:_fullname)()}"
            File( factor.join( bo_target.method(name+:_format)()[0, 2] ) ) \
              -> move( bo_target.method(name+:_fullname)() )
          }
        }...
      ).all
    )
  }

  -> make_clean_factor (/* BuiltObj */ bo_target, Bool output = false) {
    BuildSh::make_clean(output: output) && BuildSh::make_factor(bo_target, output: output)
  }

  # branchname and file name
  define BASE_REMOTE_IMAGE_URL = 'http://downloads.factorcode.org/images/%s/%s'
  define CHECKSUM_FILENAME = 'checksums.txt'
  # aka set_boot_image_vars
  -> boot_image_urls () is cached {
    -> curbranch_file_url (String filename, Bool use_non_master = true) is cached {
      BASE_REMOTE_IMAGE_URL.sprintf( (use_non_master ? BuildSh::try_git(:branch, __FUNC_NAME__) : :master), filename )
    }

    const non_master_branch_ok = Bool( BuildSh::make_http_request( curbranch_file_url(CHECKSUM_FILENAME) ) )
    Hash(
      :checksum => curbranch_file_url(CHECKSUM_FILENAME, use_non_master: non_master_branch_ok),
      :boot_image_url => curbranch_file_url( BuildSh::generate_make_targets(){:boot_image}, use_non_master: non_master_branch_ok )
    )
  }

  # failure case?
  -> _process_checksums_file (String data, String want_name) {
    data.lines.find{ .contains(want_name) }.split(" ").second
  }

  -> get_boot_image {
    const File boot_image_file = BuildSh::generate_make_targets(){:boot_image}
    say "#{__FUNC_NAME__}: Downloading boot image file #{boot_image_file}"

    const boot_image_urls = BuildSh::boot_image_urls()

    const boot_image_data = BuildSh::make_http_request( boot_image_urls{:boot_image_url} )
    const download_md5 = boot_image_data.md5

    const remote_checksum_data = BuildSh::make_http_request( boot_image_urls{:checksum} )
    if (! remote_checksum_data) {
      say "#{__FUNC_NAME__}: Can't download, can't checksum"
      return false
    }
    const remote_md5 = BuildSh::_process_checksums_file(remote_checksum_data, boot_image_file)

    say "#{__FUNC_NAME__}: boot image sums: #{remote_md5} / #{download_md5}"
    if (remote_md5 != download_md5) { die "#{__FUNC_NAME__}: !!! downloaded checksum mismatch !!! (unrecoverable)" }

    boot_image_file.touch.cleave(
      { .binmode },
      { .spurt( boot_image_data ) }
    )
  }

  -> update_boot_image {
    const File boot_image_file = BuildSh::generate_make_targets(){:boot_image}
    say "#{__FUNC_NAME__}: Removing old data..."
    File(CHECKSUM_FILENAME).remove
    # remove all boot images with a name like BOOT_IMAGE.{?,??}
    # File(boot_image_name + '*').glob.grep{ _ ~~ Regex("#{boot_image_name}\.(?:.|..)") }.map{ File(_).remove }
    File("temp/staging.*.image").glob.each{ File(_).remove }

    say "#{__FUNC_NAME__}: Processing #{boot_image_file}"

    if ( boot_image_file.exists ) {
      say "#{__FUNC_NAME__}: have a local #{boot_image_file}, need to checksum"
      const boot_image_urls = BuildSh::boot_image_urls()
      const remote_checksum_data = BuildSh::make_http_request( boot_image_urls{:checksum} )
      if (! remote_checksum_data) {
        say "#{__FUNC_NAME__}: Can't download, can't checksum"
        return false
      }
      const remote_md5 = BuildSh::_process_checksums_file(remote_checksum_data, boot_image_file)

      const local_md5 = boot_image_file.md5
      say "#{__FUNC_NAME__}: boot image sums: #{remote_md5} / #{local_md5}"

      if (remote_md5 != local_md5) {
        say "\t#{__FUNC_NAME__}: !!! local / remote checksum mismatch !!! "
        boot_image_file.remove
        return BuildSh::get_boot_image()
      }
      say "#{__FUNC_NAME__}: Local boot image matched remote sum"
      true
    } else {
      say "#{__FUNC_NAME__}: no local #{boot_image_file}, need to get"
      BuildSh::get_boot_image()
    }
  }

  -> blob_file_contents_sum (File f, Str algo) { f |> :open_r |> :slurp |> :encode_utf8 |> (algo || :sha256) }
}

include util_classes
import util_classes::BuiltObj
import util_classes::SrcSums
import util_classes::DirSum

module FactorBashStateless {

  -> make_uuid (Bool words = false, Num len = nil) -> String {
    const len = (len || words ? 7 : 32)
    if (words) {
      %f(/usr/share/dict/words).open_r.lines.grep{ _ ~~ /^\w+$/ }.sample(len).map{ .downcase }.join('_')
    } else {
      `tr -dc 'a-z0-9\-_' < /dev/urandom | fold -w#{len} | head -n1`.chomp
    }
  }

  -> read_binary_b64 (name) {
    name.open('< :raw :bytes', \var fh)
    const res = fh.slurp.encode_utf8.encode_base64
    res
    fh.close
    res
  }

  -> write_binary_b64 (name, b64) {
    name.touch
    name.open('> :raw :bytes', \var fh)
    const res = fh.spurt(b64.decode_base64.decode_utf8)
    res
    fh.close
    res
  }

  -> _test_candidate_boot_image (util_classes::BuiltObj bo, File c) {
    c.exists && (bo.blob_sums.boot == BuildSh::blob_file_contents_sum(c, bo.blob_sums.algo) )
  }

  -> _choose_boot_image (util_classes::BuiltObj bo_target, File boot_image_file) {
    # Array<Pair<Bool, File>>
    [
      Pair(
        FactorBashStateless::_test_candidate_boot_image(bo_target, bo_target.boot_fullname),
        { bo_target.boot_fullname }
      ),
      Pair(
        FactorBashStateless::_test_candidate_boot_image(bo_target, boot_image_file) \
          || BuildSh::update_boot_image(),
        { boot_image_file }
      ),
      Pair(
        bo_target.stored_boot_image.cleave(
          { _{:data}.len },
          { _{:data}.base64_decode.method( _{:algo} ) },
          { _{:sum} },
          { FactorBashStateless::write_binary_b64( bo_target.boot_fullname, _{:data} ) }
        ).cleave(
          { .first && .last },
          { [ _[1, 2] ]«==» },
        ).all,
        { bo_target.boot_fullname }
      ),
      Pair(
        "give up",
        { die "[FATAL] #{__FUNC_NAME__}: can't find or download boot image\n\tno boot image, can't compile (sorry!)" }
      )
    ].find{ .first }.cleave{ .second.run }.last.cleave(
      { say "#{__FUNC_NAME__}: !!! Chose #{_}" },
      { _ }
    ).last
  }
}

class FactorBash (Dir wd, Bool subcommand_output = false) < util_classes::WithDirectory { # < CapturedWriter??

  const DIR_REGEXES = Hash(
    :core => /^core\//,
    :basis => /^basis\//,
    :vm => /^vm\//
  )

  # TODO: compare egrep with PCRE to figure out which files are being matched differently
  -> git_files_matching (Dir d) -> Array {
    const Array files = `git ls-files`.lines.grep{ _ ~~ DIR_REGEXES{d} }
    die "[FATAL] #{__METHOD_NAME__}: no files matched #{DIR_REGEXES{d}} in #{Dir.cwd}" if (! files)
    # say "git listing #{files.len} files: #{r}"
    files
  }

  # aka hash_directory_filenames
  -> sum_git_names_matching (Dir d, Str algo) is cached -> String {
    die "#{__METHOD_NAME__}: empty 'algo'! dir: #{d}" if (algo.is_empty)
    # allow utf-8 with SHA
    self.git_files_matching(d).join("\n") |> :encode_utf8 |> algo
  }

  # TODO: make this not so slow so we don't have to use shell syntax directly
  # aka hash_directory_contents
  -> sum_git_contents_matching (Dir d, Str algo) is cached -> String {
    die "#{__METHOD_NAME__}: empty 'algo'! dir: #{d}" if (algo.is_empty)
    self.git_files_matching(d).map{
      File(_) |> :open_r |> :slurp |> :encode_utf8
    }.join("\n") |> algo
  }

  -> src_sums (String algo, Bool basis_ignored) is cached -> SrcSums {
    die "#{__METHOD_NAME__}: empty 'algo'!" if (algo.is_empty)
    self.with_directory{
      SrcSums([:vm, :core, :basis].map{
          |dir|
        dir¦ DirSum(
          algo: algo,
          names: self.sum_git_names_matching(Dir(dir), algo),
          contents: self.sum_git_contents_matching(Dir(dir), algo)
        )
      }..., basis_ignored: basis_ignored)
    }
  }

  -> delegate (String name, Block default = {}, args = ()) {
    # say "#{name} #{[@|args]}"
    var fn
    try { fn = eval("BuildSh::#{name}") } catch {}
    if ( self |> :methods |> :keys |> (:contains, name) ) {
      self.method(name)(@|args)
    } elsif (fn) {
      self.with_directory{ fn() }
    } else {
      default.run(@|args)
    }
  }

  -> say_src_sums {
    say "#{self.src_sums(:sha256, false).vm.names}  vm names"
    say "#{self.src_sums(:sha256, false).vm.contents}  vm contents"
    say "#{self.src_sums(:sha256, false).core.names}  core names"
    say "#{self.src_sums(:sha256, false).core.contents}  core contents"
    say "#{self.src_sums(:sha256, false).basis.names}  basis names"
    say "#{self.src_sums(:sha256, false).basis.contents}  basis contents"
  }

  -> say_env_info {
    const l = BuildSh::platform_lib_name()
    var cc = BuildSh::cc()
    var cxx = BuildSh::cxx()
    say "cc=#{cc}"
    say "cxx=#{cxx}"
    say "os_name=#{self.delegate(:os_name)}"
    say "os_type=#{self.delegate(:os_type)}"
    say "arch_name=#{self.delegate(:arch_name)}"
    say "word_size=#{self.delegate(:word_size)}"
    say "is_git=#{self.delegate(:is_git)}"
    say "git_branch=#{self.delegate(:git_branch)}"
    say "git_hash=#{self.delegate(:git_hash)}"
    say "platform_vm_ext=factor#{BuildSh::platform_vm_ext()}"
    say "platform_lib_name=#{l.first}factor#{l.second}"
    say "factor_version=#{self.delegate(:factor_version)}"
  }

  -> build_factor (BuiltObj bo_target) {
    self.with_directory{
      bo_target.cleave(
        { .lock }, { BuildSh::make_clean_factor(_, output: self.subcommand_output) },
        { .vm_fullname.exists }, { .lib_fullname.exists }, { .unlock }
      ).all
    }
  }

  -> _refresh_image (BuiltObj bo_target) {
    self.with_directory{
      Command::spawn_se(
        './' + bo_target.vm_fullname, '-no-user-init', "-i='#{bo_target.image_fullname}'",
        "-e='USING: vocabs.loader vocabs.refresh system memory ; refresh-all save 0 exit'",
        output: self.subcommand_output
      )
    }
  }
  -> _make_boot_image (BuiltObj bo_target, Str target, File want_name) {
    self.with_directory{
      Command::spawn_se(
        './' + bo_target.vm_fullname, '-no-user-init', "-i='#{bo_target.image_fullname}'",
        "-e='USING: system bootstrap.image memory ; \"#{target}\" make-image image-path save-image 0 exit'",
        output: self.subcommand_output
      ) && BuildSh::generate_make_targets(){:boot_image}.move(want_name)
    }
  }

  -> build_image (BuiltObj bo_target) {
    self.with_directory{
      define String lead = "==== "
      bo_target.lock

      const make_targets = BuildSh::generate_make_targets()
      const File default_boot_image_file = make_targets{:boot_image}

      # try the local one with our id
      const using_boot_image = FactorBashStateless::_choose_boot_image(bo_target, default_boot_image_file)
      # this side-effecting code will be deferred until used, except that isn't acutally what we want
      using_boot_image

      -> run_boot_image {
        Command::spawn_se("echo \"USE: system 255 (exit)\"", '|', './' + bo_target.vm_fullname, '-no-user-init' "-i='#{using_boot_image}'", output: self.subcommand_output)
      }
      var count_refresh = 1
      # NOTE: STEP 1: run from boot image
      say "#{lead}Compiling from boot image, pass \##{count_refresh}"
      if (! run_boot_image() ) {
        say "[WARN]\t#{__METHOD_NAME__}: First pass not OK, trying again"

        const updated = BuildSh::update_boot_image()

        die "[FATAL] #{__METHOD_NAME__}: Failed to update, can't recover" \
          if (!updated)

        die "[FATAL] #{__METHOD_NAME__}: Still can't run from the new boot image, something is deeply wrong" \
          if ( updated && !run_boot_image() )

        say "#{lead}Second pass OK"
      } else {
        say "#{lead}First pass OK"
      }

      const Str boot_image_base = make_targets{:boot_image_base}
      # NOTE: STEP 2: refresh-all from newly compiled image
      var Bool image_fails_refresh = !self._refresh_image(bo_target)
      # NOTE: STEP 3: re-bootstrap and refresh until it doesn't break
      while (image_fails_refresh && (count_refresh < 25) ) {
        say "#{lead}Boot image refresh \##{count_refresh} failed! bootstrapping again..."

        # NOTE: STEP 3a: new boot image
        if (! self._make_boot_image(bo_target, boot_image_base, using_boot_image) ) {
          die "[FATAL] #{__METHOD_NAME__}: failed to make a boot image (refresh \##{count_refresh}): #{$!}"
        }

        # NOTE: STEP 3b: repeat STEP 1
        run_boot_image()
        # NOTE: STEP 3b: repeat STEP 2
        image_fails_refresh = !self._refresh_image(bo_target)
        count_refresh++
      }
      die "[FATAL] Can't possibly compile a working image" if (image_fails_refresh)
      # NOTE: STEP 4: build a final boot image with the working factor.image
      const retval = using_boot_image.cleave(
        { self._make_boot_image(bo_target, boot_image_base, _) },
        { _ == bo_target.boot_fullname ? true : .copy(bo_target.boot_fullname) }
      ).all

      bo_target.unlock

      # don't delete the boot image?
      # mv boot_image my_boot_image_name
      say "#{lead}Finished image compilation after #{count_refresh} refresh#{count_refresh > 1 ? 'es' : '' }"

      retval
    }
  }
}
