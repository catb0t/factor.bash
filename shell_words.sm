#! sidef -WkP8

##  shell_words, part of MultiFactor
##    Copyright Cat Stevens 2018
##  This program is free software: you can redistribute it and/or modify
##    it under the terms of the GNU General Public License as published by
##    the Free Software Foundation, either version 3 of the License, or
##    (at your option) any later version.
##
##    This program is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
##
##    You should have received a copy of the GNU General Public License
##    along with this program.  If not, see <https://www.gnu.org/licenses/>.

module Command {
  func spawn_se (Bool output = false, *cmdline) -> Bool {
    $? = 0
    var p = Pipe(cmdline.join(' ')).open_r
    p.autoflush(true)
    p.binmode
    $| = 1
    output ? p.each_char{ .print } : p.lines;
    Number($?) == 0
  }
  func ql (Array args) -> String {
    args.map{ "#{_.quotemeta} " }.join
  }
  func make (Bool output = false, *args) -> Bool {
    Command::spawn_se('make', '-j', args..., output: output)
  }
}

# `build.sh` bash functions
# THEIR utilities, re-implemented in Sidef
module BuildSh {
  include Command
  -> downloader {
    'LWP::UserAgent'.require.new(show_progress => 1)
  }
  -> make_http_request (url) {
    var resp = BuildSh::downloader().get(url)

    if (resp.is_success) {
      resp.decoded_content
    }
    false
  }
  -> find_programs (String kind, Array ps) is cached -> String {
    STDERR.say("Look for '#{kind}': #{ps.join(', ')}...")
    for p in ps {
      const s = `which #{p.quotemeta}`.chomp
      if (Number($?) == 0) {
        STDERR.say("    found #{s}")
        return s
      }
    }
    die "no #{kind}"
  }
  # TODO: not *required*
  # -> check_cc_version (String name) is cached -> Bool {
  #   Bool(name)
  #   ...
  # }
  -> cc () is cached -> String {
    BuildSh::find_programs(:cc, %w(clang gcc cc))
  }
  -> cxx () is cached -> String {
    BuildSh::find_programs(:cxx, %w(clang++ g++ c++ cpp))
  }
  # NOTE: os_type is distinct to osname
  -> os_name () is cached -> String {
    given (Sys.osname) {
      when (/(?:windows|cygwin)/i) { :windows }
      when (:darwin) { continue }
      when (:macos) { :macos }
      when (:mingw) { continue }
      when (:linux) { :linux }
      when (/bsd/i) { :bsd }
      default { die "Unknown osname: #{Sys.osname}" }
    }
  }
  -> os_type () is cached -> String {
    given (Sys.osname) {
      when (/(?:linux|darwin|macos|bsd|mingw)/i) { :unix }
      when (/(?:windows|cygwin)/i) { :windows }
      default { die "Can't convert osname to os_type: #{Sys.osname}" }
    }
  }
  -> arch_name () is cached -> String {
    const uname = `uname -m`.chomp
    if ([:ppc64, "Power Macintosh"].any{ uname.contains(_) }) {
      :ppc
    } else {
      :x86
    }
  }
  -> c_word_size () is cached -> String {
    define File ws_binary = %f(factor_word_size)
    `echo '#include <stdio.h>
    int main(){printf(\"%ld\",(long)(8*sizeof(void*)));}' | #{BuildSh::cc()} -xc -o#{ws_binary} -`

    die "couldn't call the C compiler: #{$!}" \
      if (Number($?) != 0)

    # NOTE: can't be const, or else the value will be discarded
    var String ws = `./#{ws_binary}`
    if (Number($?) != 0) {
      var e = $!
      ws_binary.remove
      die "couldn\'t run the word size program: $!"
    }
    ws_binary.remove
    ws
  }
  -> intel_macosx_word_size () is cached -> String {
    `#{BuildSh::find_programs(:sysctl, [:sysctl])} machdep.cpu.extfeatures | grep EM64T >/dev/null`
    (Number($?)==0 ? "64" : "32")
  }
  -> word_size () is cached -> String {
    if (Sys.osname~~:macos && BuildSh::arch_name()~~:x86) {
      BuildSh::intel_macosx_word_size()
    } else {
      BuildSh::c_word_size()
    }
  }
  # format: OS-ARCH.BITS
  -> generate_make_targets () is cached {
    const (
      ot = BuildSh::os_type(),
      on = BuildSh::os_name(),
      an = BuildSh::arch_name(),
      ws = BuildSh::word_size()
    )
    Hash(
      :make_image => "#{on}-#{an}.#{ws}",            # MAKE_IMAGE_TARGET
      :make_vm => "#{on}-#{an}-#{ws}",               # MAKE_TARGET
      :boot_image_base => "#{ot}-#{an}.#{ws}",       # boot image base (no analogue)
      :boot_image => "boot.#{ot}-#{an}.#{ws}.image", # BOOT_IMAGE
    )
  }
  -> current_git_branch () is cached {
    const branch = `git rev-parse --abbrev-ref HEAD`
    (Number($?)==0 ? branch.chomp : :master)
  }

  -> platform_vm_name () is cached {
    [
      (Sys.osname~~/darwin/ ? 'F' : 'f'),
      given ( Sys.osname ) {
        when (/(?:windows|cygwin)/i) { ".exe" }
        when (/darwin/i) { ".app" }
      }
    ]
  }

  -> make_clean (Bool output = false) {
    Command::make(:clean, output: output)
  }

  -> make_factor (File final_name, Bool output = false ) {
    const target = BuildSh::generate_make_targets(){:make_vm}
    say "Building '#{target}' with infinite cores"
    const Bool retval = Command::make(target, output: output)

    var (f_case, ext) = BuildSh::platform_vm_name()...
    retval && File("#{f_case}actor#{ext}").move(final_name)
  }

  -> make_clean_factor (File final_name, Bool output = false) {
    BuildSh::make_clean(output: output) && BuildSh::make_factor(final_name, output: output)
  }

  define BASE_REMOTE_IMAGE_URL= 'http://downloads.factorcode.org/images/%s/%s' # branchname and file name
  define CHECKSUM_FILENAME = 'checksums.txt'
  # aka set_boot_image_vars
  -> boot_image_urls () is cached {
    const curbranch_file_url = -> (String filename, Bool use_non_master = true) is cached {
      BASE_REMOTE_IMAGE_URL.sprintf( (use_non_master ? BuildSh::current_git_branch() : :master), filename )
    }

    const non_master_branch_ok = Bool( BuildSh::make_http_request( curbranch_file_url(CHECKSUM_FILENAME) ) )
    Hash(
      :checksum => curbranch_file_url(CHECKSUM_FILENAME, use_non_master: non_master_branch_ok),
      :boot_image_url => curbranch_file_url( BuildSh::generate_make_targets(){:boot_image}, use_non_master: non_master_branch_ok )
    )
  }

  -> get_boot_image {
    say "Downloading #{BuildSh::generate_make_targets(){:boot_image}}"
    BuildSh::make_http_request( BuildSh::boot_image_urls(){:boot_image_url} )
  }

  -> update_boot_image {
    const boot_image_name = BuildSh::generate_make_targets(){:boot_image}
    say "Removing old data..."
    File(CHECKSUM_FILENAME).remove
    # remove all boot images with a name like BOOT_IMAGE.{?,??}
    File(boot_image_name + '*').glob.grep{ _ ~~ Regex("#{boot_image_name}\.(?:.|..)") }.map{ File(_).remove }
    File("temp/staging.*.image").glob.map{ File(_).remove }

    const File boot_image_file = File(boot_image_name)

    if ( boot_image_file.exists ) {
      const boot_image_urls = BuildSh::boot_image_urls()
      const remote_checksum_data = BuildSh::make_http_request( boot_image_urls{:checksum} )
      const remote_md5 = remote_checksum_data.lines.find{ .contains(boot_image_name) }.split(" ").first

      const local_md5 = boot_image_file.md5
      say "boot image sums: #{remote_md5} / #{local_md5}"

      if (! (remote_md5 == local_md5)) {
        say "\t!!! mismatch !!! "
        File(boot_image_name).remove
        return BuildSh::get_boot_image()
      }
      say "Local boot image matched remote sum"
      return true
    }
    BuildSh::get_boot_image()
  }
}

module FactorBashStateless {
  -> make_uuid (Number len = 32) -> String {
    `tr -dc 'a-zA-Z0-9\-_=,' < /dev/urandom | fold -w#{len} | head -n1`.chomp
  }
}

class FactorBash (Dir wd, Bool subcommand_output = false) {
  define String VM_DIR_REGEX = '^vm/'
  define String IMAGE_DIR_REGEX = '^(?:core|basis)/'

  # define Regex VM_DIR_REGEX = /^vm\//
  # define Regex IMAGE_DIR_REGEX = /^(?:core|basis)\//

  -> with_directory (Block operation) {
    # SIDEF BUG: if this is `const oldwd`, the old working directory is never restored
    var oldwd = Dir.cwd
    if (oldwd == self.wd) {
      operation.run
    } else {
      self.wd.chdir
      var r = operation.run
      oldwd.chdir
      r
    }
  }
  # TODO: compare egrep with PCRE to figure out which files are being matched differently
  -> git_files_matching (String r) -> Array {
    const Array files = Pipe("git ls-files | egrep '#{r}'").open_r.map{ File(_) } # .grep{ _ ~~ r }
    die "[ERROR] #{__METHOD_NAME__}: no files matched #{r} in #{Dir.cwd}" if (! files)
    # say "git listing #{files.len} files: #{r}"
    files
  }

  # aka hash_directory_filenames
  -> sum_git_names_matching (String r) is cached -> String {
    # allow utf-8 with SHA
    self.git_files_matching(r).join("\n").encode("utf8").sha256
  }

  # TODO: make this not so slow so we don't have to use shell syntax directly
  # aka hash_directory_contents
  -> sum_git_contents_matching (String r) is cached -> String {
    self.git_files_matching(r).map{
      # if we sha256ed the file itself we wouldn't have to read it ourselves
      # but that would mean sha256ing each file individually which might be slower
      # and is probably not the right answer anyways
      .open_r.slurp.encode("utf8")
    }.join("\n").sha256
  }

  # -> sum_git_contents_matching_shell (String r) -> String {
  #   # say self.git_files_matching(r).join(" ")
  #   `git ls-files | egrep '#{r}' | xargs cat | sha256sum | cut -f1 -d' '`.chomp
  # }

  # c++ files
  ->  sum_vm_source () is cached {
    self.with_directory{
      Hash(
        :names => self.sum_git_names_matching(VM_DIR_REGEX),
        :contents => self.sum_git_contents_matching(VM_DIR_REGEX)
      )
    }
  }

  # .factor files
  -> sum_image_source () is cached {
    self.with_directory{
      Hash(
        :names => self.sum_git_names_matching(IMAGE_DIR_REGEX),
        :contents => self.sum_git_contents_matching(IMAGE_DIR_REGEX)
      )
    }
  }

  -> say_src_sums {
    say "#{self.sum_vm_source\{:names}}  vm_names"
    say "#{self.sum_vm_source\{:contents}}  vm_contents"
    say "#{self.sum_image_source\{:names}}  image_names"
    say "#{self.sum_image_source\{:contents}}  image_contents"
  }

  -> say_env_info {
    const p = BuildSh::platform_vm_name()
    var cc = BuildSh::cc()
    var cxx = BuildSh::cxx()
    say "cc=#{cc}"
    say "cxx=#{cxx}"
    say "os_type=#{BuildSh::os_type()}"
    say "os_name=#{BuildSh::os_name()}"
    say "arch_name=#{BuildSh::arch_name()}"
    say "word_size=#{BuildSh::word_size()}"
    say "git_branch=#{BuildSh::current_git_branch()}"
    say "platform_vm_name=#{p.first}actor#{p.second}"
  }

  -> refresh_image (File vm_name, File image_name) {
    self.with_directory{
      Command::spawn_se(
        './' + vm_name, '-no-user-init', "-i='#{image_name}'",
        "-e='USING: vocabs.loader vocabs.refresh system memory ; refresh-all save 0 exit'",
        output: self.subcommand_output
      )
    }
  }
  -> make_boot_image (File vm_name, File image_name) {
    self.with_directory{
      Command::spawn_se(
        './' + vm_name, '-no-user-init', "-i'#{image_name}'", "-e='USING: system bootstrap.image memory ; " +
        "\"#{BuildSh::generate_make_targets(){:boot_image_base}}\" make-image image-path save-image 0 exit'",
        output: self.subcommand_output
      )
    }
  }
  -> build_factor (File final_name) {
    self.with_directory{
      const ret = BuildSh::make_clean_factor(final_name, output: self.subcommand_output)
      ret && final_name.exists
    }
  }
  -> build_image (File vm_name, File image_name) {
    self.with_directory{
      const boot_image_file = File(BuildSh::generate_make_targets(){:boot_image})

      const have_boot_image = ( boot_image_file.exists || BuildSh::update_boot_image || self.get_boot_image || false )
      die "[ERROR] can't find or download boot image\n\tno boot image, can't compile (sorry!)" \
        if (! have_boot_image)

      # say "#{boot_image_file}"
      -> run_boot_image {
        Command::spawn_se('./' + vm_name, '-no-user-init' "-i='#{boot_image_file}'", output: self.subcommand_output)
      }
      var count_refresh = 1
      # NOTE: STEP 1: run from boot image
      say "Compiling from boot image, pass \##{count_refresh}"
      run_boot_image()

      # NOTE: STEP 2: `refresh-all` from newly compiled image
      var image_fails_refresh = !self.refresh_image(vm_name, image_name)

      # NOTE: STEP 3: re-bootstrap and refresh until it doesn't break
      for (true; image_fails_refresh && (count_refresh < 25); count_refresh++ ) {
        say "Boot image refresh \##{count_refresh} failed! bootstrapping again..."

        # NOTE: STEP 3a: new boot image
        self.make_boot_image(vm_name, image_name)

        # NOTE: STEP 3b: repeat STEP 1
        run_boot_image()
        # NOTE: STEP 3b: repeat STEP 2
        image_fails_refresh = !self.refresh_image(vm_name, image_name)
      }
      # NOTE: STEP 4: build a final boot image with the working factor.image
      const retval = self.make_boot_image(vm_name, image_name)
      # don't delete the boot image?
      # mv boot_image my_boot_image_name
      say "finished image compilation after #{count_refresh} refresh#{count_refresh > 1 ? 'es' : '' }"
      retval
    }
  }
}
