#! sidef -WkP8

##  shell_words, part of MultiFactor
##    Copyright Cat Stevens 2018
##  This program is free software: you can redistribute it and/or modify
##    it under the terms of the GNU General Public License as published by
##    the Free Software Foundation, either version 3 of the License, or
##    (at your option) any later version.
##
##    This program is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
##
##    You should have received a copy of the GNU General Public License
##    along with this program.  If not, see <https://www.gnu.org/licenses/>.

module Command {
  func ql (Array args) -> String {
    args.map{ "#{_.quotemeta} " }.join
  }
  func make (*args) -> Number {
    `make -j #{ql(args)}`
    Number($?)
  }
  func rm (Array args, Array opts = []) -> Number {
    # say args.dump
    # say opts.dump
    `rm #{ql(opts)} #{ql(args)}`
    Number($?)
  }
  func mv (from, to, Array opts = []) -> Number {
    `cp #{ql(opts)} '#{from}' '#{to}'`
    Number($?)
  }
  func cp (from, to, Array opts = []) -> Number {
    `cp #{ql(opts)} '#{from}' '#{to}'`
    Number($?)
  }
}

# `build.sh` bash functions
# THEIR utilities, re-implemented in Sidef
module BuildSh {
  include Command
  -> downloader {
    'LWP::UserAgent'.require.new(show_progress => 1)
  }
  -> make_http_request (url) {
    var resp = BuildSh::downloader().get(url)

    if (resp.is_success) {
      resp.decoded_content
    }
    false
  }
  -> find_programs (String kind, Array ps) is cached -> String {
    say "Look for '#{kind}': #{ps.join(', ')}..."
    # could probably optimise this by just returning the first match
    for p in ps {
      const s = `which #{p.quotemeta}`.chomp
      if (Number($?) == 0) {
        say "\tfound #{s}"
        return s
      }
    }
    die "no #{kind}"
  }
  # TODO: not *required*
  -> check_cc_version (String name) is cached -> Bool {
    Bool(name)
    ...
  }
  -> cc () is cached -> String {
    BuildSh::find_programs(:cc, %w(clang gcc cc))
  }
  -> cxx () is cached -> String {
    BuildSh::find_programs(:cxx, %w(clang++ g++ c++ cpp))
  }
  # NOTE: os_type is distinct to osname
  -> os_name () is cached -> String {
    given (Sys.osname) {
      when (/(?:windows|cygwin)/i) { :windows }
      when (:darwin) { continue }
      when (:macos) { :macos }
      when (:mingw) { continue }
      when (:linux) { :linux }
      when (/bsd/i) { :bsd }
      default { die "Unknown osname: #{Sys.osname}" }
    }
  }
  -> os_type () is cached -> String {
    given (Sys.osname) {
      when (/(?:linux|darwin|macos|bsd|mingw)/i) { :unix }
      when (/(?:windows|cygwin)/i) { :windows }
      default { die "Can't convert osname to os_type: #{Sys.osname}" }
    }
  }
  -> arch_name () is cached -> String {
    if ([:ppc64, "Power Macintosh"].contains(`uname -m`.chomp)) {
      :ppc
    } else {
      :x86
    }
  }
  -> c_word_size () is cached -> String {
    define File ws_name = %f(factor_word_size)
    `echo '#include <stdio.h>
int main(){printf(\"%ld\",(long)(8*sizeof(void*)));}' | #{BuildSh::cc()} -xc -o#{ws_name} -`

    die "couldn't call the C compiler: $!" \
      if (Number($?) != 0)

    # NOTE: can't be const, or else the value will be discarded
    var String ws = `./#{ws_name}`
    if (Number($?) != 0) {
      var e = $!
      ws_name.remove
      # Command::rm([ws_name])
      die "couldn\'t run the word size program: $!"
    }
    ws_name.remove
    # Command::rm([ws_name])
    ws
  }
  -> intel_macosx_word_size () is cached -> String {
    `#{BuildSh::find_programs(:sysctl, ["sysctl"])} machdep.cpu.extfeatures | grep EM64T >/dev/null`
    (Number($?)==0 ? "64" : "32")
  }
  -> word_size () is cached -> String {
    if (Sys.osname~~"macos" && BuildSh::arch_name()~~:x86) {
      BuildSh::intel_macosx_word_size()
    } else {
      BuildSh::c_word_size()
    }
  }
  # format: OS-ARCH.BITS
  -> generate_make_targets () is cached {
    const (
      os = BuildSh::os_type(),
      an = BuildSh::arch_name(),
      ws = BuildSh::word_size()
    )
    Hash(
      :make_image => "#{os}-#{an}.#{ws}",           # MAKE_IMAGE_TARGET
      :make_vm => "#{os}-#{an}-#{ws}",              # MAKE_TARGET
      :boot_image => "boot.#{os}-#{an}.#{ws}.image",# BOOT_IMAGE
    )
  }
  -> current_git_branch () is cached {
    const branch = `git rev-parse --abbrev-ref HEAD`
    (Number($?)==0 ? branch : :master)
  }
}

module FactorBashStateless {
  -> make_uuid (Number len = 32) -> String {
    `tr -dc 'a-zA-Z0-9\-_=,' < /dev/urandom | fold -w#{len} | head -n1`.chomp
  }
}

class FactorBash (Dir wd) {
  define String VM_DIR_REGEX = '^vm/'
  define String IMAGE_DIR_REGEX = '^(?:core|basis)/'

  # define Regex VM_DIR_REGEX = /^vm\//
  # define Regex IMAGE_DIR_REGEX = /^(?:core|basis)\//

  -> with_directory (Block operation) {
    # SIDEF BUG: if this is `const oldwd`, the old working directory is never restored
    var oldwd = Dir.cwd
    self.wd.chdir
    var retval = operation.run
    oldwd.chdir
    retval
  }

  -> git_files_matching (String r) -> Array {
    const Array files = `git ls-files | egrep '#{r}'`.lines.map{ .chomp } # .grep{ _ ~~ r }
    die "[ERROR] #{__METHOD_NAME__}: no files matched #{r} in #{Dir.cwd}" if (! files)
    # say "git listing #{files.len} files: #{r}"
    files
  }

  # aka hash_directory_filenames
  -> sum_git_names_matching (String r) -> String {
    # allow utf-8 with SHA
    self.git_files_matching(r).join("\n").bytes.map{ .chr }.join.sha256
  }

  # TODO: make this not so slow so we don't have to use shell syntax directly
  # aka hash_directory_contents
  -> sum_git_contents_matching_native (String r) -> String {
    self.git_files_matching(r).map{
        |fname|
      # allow utf-8 with SHA
      const fh = File(fname).open_r
      const c = fh.slurp
      c
      fh.close
      c.bytes.map{ .chr }.join.sha256
    }.join("\n").sha256
  }

  -> sum_git_contents_matching_shell (String r) -> String {
    # say self.git_files_matching(r).join(" ")
    `git ls-files | egrep '#{r}' | xargs cat | sha256sum | cut -f1 -d' '`.chomp
  }

  # c++ files
  ->  sum_vm_source {
    self.with_directory({
      Hash(
        :names => self.sum_git_names_matching(VM_DIR_REGEX),
        :contents => self.sum_git_contents_matching_shell(VM_DIR_REGEX)
      )
    })
  }

  # .factor files
  -> sum_image_source {
    self.with_directory({
      Hash(
        :names => self.sum_git_names_matching(IMAGE_DIR_REGEX),
        :contents => self.sum_git_contents_matching_shell(IMAGE_DIR_REGEX)
      )
    })
  }
}
